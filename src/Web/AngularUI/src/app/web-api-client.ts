//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    addresses(): Observable<PaginatedListOfAddressDto>;
    deleteAddress(id: number): Observable<void>;
    create(command: CreateAddressRequest): Observable<number>;
    applicantInfo(): Observable<ApplicantVm>;
    getForm(): Observable<ApplicationType[]>;
    saveFormChanges(command: CreateFormUpdateRequest): Observable<boolean>;
    createBiodata(command: CreateBiodataRequest): Observable<number>;
    choice(): Observable<ChoicesDto>;
    index(): Observable<UserDto>;
    getUploadedDocuments(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfDocumentUploadDto>;
    createUploadedDocuments(command: UploadDocumentRequest): Observable<number>;
    getEducationalBackgroundInfo(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfSHSAttendedDto>;
    createEducationalBackgroundInfo(command: SHSAttendedRequest): Observable<number>;
    deleteEducationalBackgroundInfo(id: number): Observable<void>;
    uploadImages(command: UploadPictureRequest): Observable<number>;
    previewForm(): Observable<ApplicantVm>;
    previewUniversity(): Observable<UniversityAttendedDto>;
    previewShs(): Observable<SHSAttendedDto>;
    getProgrammeById(id: number): Observable<ProgrammeDto>;
    finalized(command: FinalizedRequest): Observable<number>;
    getProgrammeInformation(): Observable<ApplicantVm>;
    createProgrammes(command: ProgrammeInfoRequest): Observable<number>;
    getRefereeInfo(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfRefereeDto>;
    createRefereeInfo(command: CreateRefereeRequest): Observable<number>;
    deleteRefereeInfo(id: number): Observable<void>;
    getResearchExperience(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfResearchExperienceDto>;
    createResearchExperience(command: ResearchExperienceRequest): Observable<number>;
    deleteResearchExperience(id: number): Observable<void>;
    getResearchPublication(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfResearchPublicationDto>;
    createResearchPublication(command: ResearchPublicationRequest): Observable<number>;
    deleteResearchPublication(id: number): Observable<void>;
    getUploadedResults(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfResultsDto>;
    uploadResults(command: CreateResultRequest): Observable<number>;
    deleteUploadResults(id: number): Observable<void>;
    getRegions(): Observable<RegionDto[]>;
    getCountries(): Observable<CountryDto[]>;
    getSHSAttended(): Observable<PaginatedListOfSHSAttendedDto>;
    getSchools(): Observable<FormerSchoolDto[]>;
    getDenominations(): Observable<DenominationDto[]>;
    getReligion(): Observable<ReligionDto[]>;
    getProgrammes(): Observable<ProgrammeDto[]>;
    getSHSProgrammes(): Observable<SHSProgrammesDto[]>;
    getSubjects(): Observable<SubjectDto[]>;
    getLanguage(): Observable<LanguageDto[]>;
    getGrades(): Observable<GradeDto[]>;
    getExams(): Observable<ExamDto[]>;
    getDistricts(): Observable<DistrictDto[]>;
    getDisabilities(): Observable<string[]>;
    getTodoItemsWithPagination(listId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfTodoItemBriefDto>;
    createTodoItem(command: CreateTodoItemCommand): Observable<number>;
    updateTodoItem(id: number, command: UpdateTodoItemCommand): Observable<void>;
    deleteTodoItem(id: number): Observable<void>;
    updateTodoItemDetail(id: number, command: UpdateTodoItemDetailCommand): Observable<void>;
    getTodoLists(): Observable<TodosVm>;
    createTodoList(command: CreateTodoListCommand): Observable<number>;
    updateTodoList(id: number, command: UpdateTodoListCommand): Observable<void>;
    deleteTodoList(id: number): Observable<void>;
    postApiUsersRegister(registration: RegisterRequest | undefined): Observable<void>;
    postApiUsersLogin(useCookies: boolean | null | undefined, useSessionCookies: boolean | null | undefined, login: LoginRequest | undefined): Observable<AccessTokenResponse>;
    postApiUsersRefresh(refreshRequest: RefreshRequest | undefined): Observable<AccessTokenResponse>;
    getApiUsersConfirmEmail(userId: string | null | undefined, code: string | null | undefined, changedEmail: string | null | undefined): Observable<void>;
    postApiUsersResendConfirmationEmail(resendRequest: ResendConfirmationEmailRequest | undefined): Observable<void>;
    postApiUsersForgotPassword(resetRequest: ForgotPasswordRequest | undefined): Observable<void>;
    postApiUsersResetPassword(resetRequest: ResetPasswordRequest | undefined): Observable<void>;
    postApiUsersManage2fa(tfaRequest: TwoFactorRequest | undefined): Observable<TwoFactorResponse>;
    getApiUsersManageInfo(): Observable<InfoResponse>;
    postApiUsersManageInfo(infoRequest: InfoRequest | undefined): Observable<InfoResponse>;
    getWeatherForecasts(): Observable<WeatherForecast[]>;
    getWorkingExperience(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfWorkingExperienceDto>;
    createWorkingExperience(command: WorkingExperienceRequest): Observable<number>;
    deleteWorkingExperience(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    addresses(): Observable<PaginatedListOfAddressDto> {
        let url_ = this.baseUrl + "/api/Address/Addresses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddresses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfAddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfAddressDto>;
        }));
    }

    protected processAddresses(response: HttpResponseBase): Observable<PaginatedListOfAddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfAddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAddress(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Address/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateAddressRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/Address/Address/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    applicantInfo(): Observable<ApplicantVm> {
        let url_ = this.baseUrl + "/api/Applicant/ApplicantInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplicantInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplicantInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicantVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicantVm>;
        }));
    }

    protected processApplicantInfo(response: HttpResponseBase): Observable<ApplicantVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicantVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getForm(): Observable<ApplicationType[]> {
        let url_ = this.baseUrl + "/api/Applicant/GetForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationType[]>;
        }));
    }

    protected processGetForm(response: HttpResponseBase): Observable<ApplicationType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveFormChanges(command: CreateFormUpdateRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Applicant/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFormChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFormChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveFormChanges(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createBiodata(command: CreateBiodataRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/Biodata/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBiodata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBiodata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateBiodata(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    choice(): Observable<ChoicesDto> {
        let url_ = this.baseUrl + "/api/Choices/Choices";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChoicesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChoicesDto>;
        }));
    }

    protected processChoice(response: HttpResponseBase): Observable<ChoicesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChoicesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    index(): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/Dashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndex(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processIndex(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUploadedDocuments(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfDocumentUploadDto> {
        let url_ = this.baseUrl + "/api/DocumentUpload/GetUploadedDocuments?";
        if (resultId === undefined || resultId === null)
            throw new Error("The parameter 'resultId' must be defined and cannot be null.");
        else
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUploadedDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUploadedDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfDocumentUploadDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfDocumentUploadDto>;
        }));
    }

    protected processGetUploadedDocuments(response: HttpResponseBase): Observable<PaginatedListOfDocumentUploadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfDocumentUploadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createUploadedDocuments(command: UploadDocumentRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/DocumentUpload/CreateUploadedDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUploadedDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUploadedDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateUploadedDocuments(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEducationalBackgroundInfo(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfSHSAttendedDto> {
        let url_ = this.baseUrl + "/api/EducationalBackground/GetEducationalBackgroundInfo?";
        if (resultId === undefined || resultId === null)
            throw new Error("The parameter 'resultId' must be defined and cannot be null.");
        else
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEducationalBackgroundInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEducationalBackgroundInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfSHSAttendedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfSHSAttendedDto>;
        }));
    }

    protected processGetEducationalBackgroundInfo(response: HttpResponseBase): Observable<PaginatedListOfSHSAttendedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfSHSAttendedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createEducationalBackgroundInfo(command: SHSAttendedRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/EducationalBackground/CreateEducationalBackgroundInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEducationalBackgroundInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEducationalBackgroundInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateEducationalBackgroundInfo(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteEducationalBackgroundInfo(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/EducationalBackground/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEducationalBackgroundInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEducationalBackgroundInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteEducationalBackgroundInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadImages(command: UploadPictureRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/PhotoUpload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUploadImages(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    previewForm(): Observable<ApplicantVm> {
        let url_ = this.baseUrl + "/api/Preview/PreviewForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviewForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviewForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicantVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicantVm>;
        }));
    }

    protected processPreviewForm(response: HttpResponseBase): Observable<ApplicantVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicantVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    previewUniversity(): Observable<UniversityAttendedDto> {
        let url_ = this.baseUrl + "/api/Preview/PreviewUniversity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviewUniversity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviewUniversity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UniversityAttendedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UniversityAttendedDto>;
        }));
    }

    protected processPreviewUniversity(response: HttpResponseBase): Observable<UniversityAttendedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UniversityAttendedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    previewShs(): Observable<SHSAttendedDto> {
        let url_ = this.baseUrl + "/api/Preview/PreviewShs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviewShs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviewShs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SHSAttendedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SHSAttendedDto>;
        }));
    }

    protected processPreviewShs(response: HttpResponseBase): Observable<SHSAttendedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SHSAttendedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProgrammeById(id: number): Observable<ProgrammeDto> {
        let url_ = this.baseUrl + "/api/Preview/GetProgrammeById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgrammeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgrammeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProgrammeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProgrammeDto>;
        }));
    }

    protected processGetProgrammeById(response: HttpResponseBase): Observable<ProgrammeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgrammeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    finalized(command: FinalizedRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/Preview/Finalized";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinalized(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinalized(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processFinalized(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProgrammeInformation(): Observable<ApplicantVm> {
        let url_ = this.baseUrl + "/api/ProgrammeInformation/GetProgrammeInformation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgrammeInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgrammeInformation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicantVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicantVm>;
        }));
    }

    protected processGetProgrammeInformation(response: HttpResponseBase): Observable<ApplicantVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicantVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProgrammes(command: ProgrammeInfoRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/ProgrammeInformation/Info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProgrammes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProgrammes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateProgrammes(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRefereeInfo(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfRefereeDto> {
        let url_ = this.baseUrl + "/api/Referee/GetRefereeInfo?";
        if (resultId === undefined || resultId === null)
            throw new Error("The parameter 'resultId' must be defined and cannot be null.");
        else
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefereeInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefereeInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfRefereeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfRefereeDto>;
        }));
    }

    protected processGetRefereeInfo(response: HttpResponseBase): Observable<PaginatedListOfRefereeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfRefereeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createRefereeInfo(command: CreateRefereeRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/Referee/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRefereeInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRefereeInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateRefereeInfo(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRefereeInfo(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Referee/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRefereeInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRefereeInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRefereeInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getResearchExperience(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfResearchExperienceDto> {
        let url_ = this.baseUrl + "/api/ResearchExperience/GetResearchExperience?";
        if (resultId === undefined || resultId === null)
            throw new Error("The parameter 'resultId' must be defined and cannot be null.");
        else
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResearchExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResearchExperience(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfResearchExperienceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfResearchExperienceDto>;
        }));
    }

    protected processGetResearchExperience(response: HttpResponseBase): Observable<PaginatedListOfResearchExperienceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfResearchExperienceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createResearchExperience(command: ResearchExperienceRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/ResearchExperience/CreateResearchExperience";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateResearchExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateResearchExperience(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateResearchExperience(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteResearchExperience(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/ResearchExperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteResearchExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteResearchExperience(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteResearchExperience(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getResearchPublication(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfResearchPublicationDto> {
        let url_ = this.baseUrl + "/api/ResearchPublication/GetResearchPublication?";
        if (resultId === undefined || resultId === null)
            throw new Error("The parameter 'resultId' must be defined and cannot be null.");
        else
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResearchPublication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResearchPublication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfResearchPublicationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfResearchPublicationDto>;
        }));
    }

    protected processGetResearchPublication(response: HttpResponseBase): Observable<PaginatedListOfResearchPublicationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfResearchPublicationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createResearchPublication(command: ResearchPublicationRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/ResearchPublication/CreateResearchPublication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateResearchPublication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateResearchPublication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateResearchPublication(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteResearchPublication(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/ResearchPublication/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteResearchPublication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteResearchPublication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteResearchPublication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUploadedResults(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfResultsDto> {
        let url_ = this.baseUrl + "/api/ResultUpload/GetUploadedResults?";
        if (resultId === undefined || resultId === null)
            throw new Error("The parameter 'resultId' must be defined and cannot be null.");
        else
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUploadedResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUploadedResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfResultsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfResultsDto>;
        }));
    }

    protected processGetUploadedResults(response: HttpResponseBase): Observable<PaginatedListOfResultsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfResultsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadResults(command: CreateResultRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/ResultUpload/UploadResults";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUploadResults(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteUploadResults(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/ResultUpload/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUploadResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUploadResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUploadResults(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRegions(): Observable<RegionDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/Regions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegionDto[]>;
        }));
    }

    protected processGetRegions(response: HttpResponseBase): Observable<RegionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCountries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/Countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSHSAttended(): Observable<PaginatedListOfSHSAttendedDto> {
        let url_ = this.baseUrl + "/api/SelectBox/SHSAttended";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSHSAttended(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSHSAttended(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfSHSAttendedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfSHSAttendedDto>;
        }));
    }

    protected processGetSHSAttended(response: HttpResponseBase): Observable<PaginatedListOfSHSAttendedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfSHSAttendedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSchools(): Observable<FormerSchoolDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/Schools";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSchools(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchools(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FormerSchoolDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FormerSchoolDto[]>;
        }));
    }

    protected processGetSchools(response: HttpResponseBase): Observable<FormerSchoolDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FormerSchoolDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDenominations(): Observable<DenominationDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/Denominations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDenominations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDenominations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DenominationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DenominationDto[]>;
        }));
    }

    protected processGetDenominations(response: HttpResponseBase): Observable<DenominationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DenominationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReligion(): Observable<ReligionDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/GetReligion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReligion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReligion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReligionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReligionDto[]>;
        }));
    }

    protected processGetReligion(response: HttpResponseBase): Observable<ReligionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReligionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProgrammes(): Observable<ProgrammeDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/GetProgrammes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgrammes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgrammes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProgrammeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProgrammeDto[]>;
        }));
    }

    protected processGetProgrammes(response: HttpResponseBase): Observable<ProgrammeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProgrammeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSHSProgrammes(): Observable<SHSProgrammesDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/GetSHSProgrammes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSHSProgrammes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSHSProgrammes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SHSProgrammesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SHSProgrammesDto[]>;
        }));
    }

    protected processGetSHSProgrammes(response: HttpResponseBase): Observable<SHSProgrammesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SHSProgrammesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubjects(): Observable<SubjectDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/GetSubjects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectDto[]>;
        }));
    }

    protected processGetSubjects(response: HttpResponseBase): Observable<SubjectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubjectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLanguage(): Observable<LanguageDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/GetLanguage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageDto[]>;
        }));
    }

    protected processGetLanguage(response: HttpResponseBase): Observable<LanguageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getGrades(): Observable<GradeDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/GetGrades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGrades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGrades(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeDto[]>;
        }));
    }

    protected processGetGrades(response: HttpResponseBase): Observable<GradeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GradeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getExams(): Observable<ExamDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/GetExams";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExams(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamDto[]>;
        }));
    }

    protected processGetExams(response: HttpResponseBase): Observable<ExamDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExamDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDistricts(): Observable<DistrictDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/GetDistricts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistricts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistricts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DistrictDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DistrictDto[]>;
        }));
    }

    protected processGetDistricts(response: HttpResponseBase): Observable<DistrictDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DistrictDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDisabilities(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/SelectBox/GetDisabilities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDisabilities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDisabilities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetDisabilities(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTodoItemsWithPagination(listId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfTodoItemBriefDto> {
        let url_ = this.baseUrl + "/api/TodoItems?";
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined and cannot be null.");
        else
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTodoItemsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTodoItemsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTodoItemBriefDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTodoItemBriefDto>;
        }));
    }

    protected processGetTodoItemsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfTodoItemBriefDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTodoItemBriefDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createTodoItem(command: CreateTodoItemCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTodoItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTodoItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateTodoItem(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTodoItem(id: number, command: UpdateTodoItemCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTodoItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTodoItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTodoItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTodoItem(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTodoItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTodoItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTodoItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTodoItemDetail(id: number, command: UpdateTodoItemDetailCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTodoItemDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTodoItemDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTodoItemDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTodoLists(): Observable<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTodoLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTodoLists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TodosVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TodosVm>;
        }));
    }

    protected processGetTodoLists(response: HttpResponseBase): Observable<TodosVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createTodoList(command: CreateTodoListCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTodoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTodoList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateTodoList(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTodoList(id: number, command: UpdateTodoListCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTodoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTodoList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTodoList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTodoList(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTodoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTodoList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTodoList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersRegister(registration: RegisterRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registration);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiUsersRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersLogin(useCookies: boolean | null | undefined, useSessionCookies: boolean | null | undefined, login: LoginRequest | undefined): Observable<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Users/login?";
        if (useCookies !== undefined && useCookies !== null)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies !== undefined && useSessionCookies !== null)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessTokenResponse>;
        }));
    }

    protected processPostApiUsersLogin(response: HttpResponseBase): Observable<AccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersRefresh(refreshRequest: RefreshRequest | undefined): Observable<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Users/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessTokenResponse>;
        }));
    }

    protected processPostApiUsersRefresh(response: HttpResponseBase): Observable<AccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiUsersConfirmEmail(userId: string | null | undefined, code: string | null | undefined, changedEmail: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/confirmEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail !== undefined && changedEmail !== null)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiUsersConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiUsersConfirmEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetApiUsersConfirmEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersResendConfirmationEmail(resendRequest: ResendConfirmationEmailRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resendRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersResendConfirmationEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersResendConfirmationEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiUsersResendConfirmationEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersForgotPassword(resetRequest: ForgotPasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiUsersForgotPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersResetPassword(resetRequest: ResetPasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiUsersResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersManage2fa(tfaRequest: TwoFactorRequest | undefined): Observable<TwoFactorResponse> {
        let url_ = this.baseUrl + "/api/Users/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tfaRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersManage2fa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersManage2fa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwoFactorResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwoFactorResponse>;
        }));
    }

    protected processPostApiUsersManage2fa(response: HttpResponseBase): Observable<TwoFactorResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwoFactorResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiUsersManageInfo(): Observable<InfoResponse> {
        let url_ = this.baseUrl + "/api/Users/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiUsersManageInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiUsersManageInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InfoResponse>;
        }));
    }

    protected processGetApiUsersManageInfo(response: HttpResponseBase): Observable<InfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersManageInfo(infoRequest: InfoRequest | undefined): Observable<InfoResponse> {
        let url_ = this.baseUrl + "/api/Users/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(infoRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersManageInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersManageInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InfoResponse>;
        }));
    }

    protected processPostApiUsersManageInfo(response: HttpResponseBase): Observable<InfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWeatherForecasts(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecasts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeatherForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeatherForecasts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGetWeatherForecasts(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWorkingExperience(resultId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfWorkingExperienceDto> {
        let url_ = this.baseUrl + "/api/WorkingExperience/GetWorkingExperience?";
        if (resultId === undefined || resultId === null)
            throw new Error("The parameter 'resultId' must be defined and cannot be null.");
        else
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkingExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkingExperience(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfWorkingExperienceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfWorkingExperienceDto>;
        }));
    }

    protected processGetWorkingExperience(response: HttpResponseBase): Observable<PaginatedListOfWorkingExperienceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfWorkingExperienceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createWorkingExperience(command: WorkingExperienceRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/WorkingExperience/CreateWorkingExperience";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWorkingExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWorkingExperience(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateWorkingExperience(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWorkingExperience(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/WorkingExperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWorkingExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWorkingExperience(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteWorkingExperience(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class PaginatedListOfAddressDto implements IPaginatedListOfAddressDto {
    items?: AddressDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AddressDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfAddressDto {
    items?: AddressDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AddressDto implements IAddressDto {
    id?: number;
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;
    applicant?: ApplicantModel | undefined;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.street = _data["street"];
            this.houseNumber = _data["houseNumber"];
            this.city = _data["city"];
            this.gprs = _data["gprs"];
            this.box = _data["box"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["street"] = this.street;
        data["houseNumber"] = this.houseNumber;
        data["city"] = this.city;
        data["gprs"] = this.gprs;
        data["box"] = this.box;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddressDto {
    id?: number;
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;
    applicant?: ApplicantModel | undefined;
}

export abstract class BaseEntity implements IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];

    constructor(data?: IBaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                this.domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    this.domainEvents!.push(BaseEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];
}

export abstract class BaseAuditableEntity extends BaseEntity implements IBaseAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;

    constructor(data?: IBaseAuditableEntity) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static override fromJS(data: any): BaseAuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseAuditableEntity' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        super.toJSON(data);
        return data;
    }
}

export interface IBaseAuditableEntity extends IBaseEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;
}

export class ApplicantModel extends BaseAuditableEntity implements IApplicantModel {
    applicationNumber?: ApplicationNumber | undefined;
    title?: Title;
    applicantName?: ApplicantName | undefined;
    previousName?: ApplicantName | undefined;
    dob?: Date;
    gender?: Gender;
    age?: number;
    maritalStatus?: MaritalStatus | undefined;
    noOfChildren?: number | undefined;
    phone?: PhoneNumber | undefined;
    altPhone?: PhoneNumber | undefined;
    email?: EmailAddress | undefined;
    emergencyContact?: PhoneNumber | undefined;
    hometown?: string | undefined;
    districtId?: number | undefined;
    district?: DistrictModel | undefined;
    hall?: HallModel | undefined;
    idCard?: IdCard | undefined;
    regionId?: number | undefined;
    region?: RegionModel | undefined;
    nationalityId?: number | undefined;
    nationality?: CountryModel | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: PhoneNumber | undefined;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability | undefined;
    sourceOfFinance?: string | undefined;
    religionId?: number | undefined;
    religion?: ReligionModel | undefined;
    denomination?: string | undefined;
    referrals?: string | undefined;
    entryMode?: Session | undefined;
    firstQualification?: EntryQualification | undefined;
    secondQualification?: EntryQualification | undefined;
    programmeStudied?: string | undefined;
    formerSchool?: string | undefined;
    formerSchoolNewId?: number | undefined;
    formerSchoolNew?: FormerSchoolModel | undefined;
    programmeAdmittedId?: number | undefined;
    lastYearInSchool?: number | undefined;
    awaiting?: boolean | undefined;
    indexNo?: string | undefined;
    grade?: number | undefined;
    yearOfAdmission?: string | undefined;
    preferredHall?: string | undefined;
    results?: string | undefined;
    externalHostel?: string | undefined;
    eligible?: boolean | undefined;
    admitted?: boolean | undefined;
    admittedBy?: number | undefined;
    dateAdmitted?: Date | undefined;
    admissionType?: AdmissionType | undefined;
    levelAdmitted?: string | undefined;
    sectionAdmitted?: string | undefined;
    hallAdmitted?: number | undefined;
    roomNo?: string | undefined;
    status?: ApplicationStatus | undefined;
    receivedSms?: boolean | undefined;
    letterPrinted?: boolean | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    feePaying?: boolean | undefined;
    reportedInSchool?: boolean | undefined;
    feesPaid?: Money | undefined;
    hallFeesPaid?: Money | undefined;
    reported?: boolean | undefined;
    sponsorShip?: boolean | undefined;
    sponsorShipCompany?: string | undefined;
    sponsorShipLocation?: string | undefined;
    sponsorShipCompanyContact?: string | undefined;
    applicationUserId?: string | undefined;
    previousIndexNumber?: string | undefined;
    getFullName?: string;
    programmes?: ProgrammeModel[] | undefined;

    constructor(data?: IApplicantModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.applicationNumber = _data["applicationNumber"] ? ApplicationNumber.fromJS(_data["applicationNumber"]) : <any>undefined;
            this.title = _data["title"];
            this.applicantName = _data["applicantName"] ? ApplicantName.fromJS(_data["applicantName"]) : <any>undefined;
            this.previousName = _data["previousName"] ? ApplicantName.fromJS(_data["previousName"]) : <any>undefined;
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.age = _data["age"];
            this.maritalStatus = _data["maritalStatus"];
            this.noOfChildren = _data["noOfChildren"];
            this.phone = _data["phone"] ? PhoneNumber.fromJS(_data["phone"]) : <any>undefined;
            this.altPhone = _data["altPhone"] ? PhoneNumber.fromJS(_data["altPhone"]) : <any>undefined;
            this.email = _data["email"] ? EmailAddress.fromJS(_data["email"]) : <any>undefined;
            this.emergencyContact = _data["emergencyContact"] ? PhoneNumber.fromJS(_data["emergencyContact"]) : <any>undefined;
            this.hometown = _data["hometown"];
            this.districtId = _data["districtId"];
            this.district = _data["district"] ? DistrictModel.fromJS(_data["district"]) : <any>undefined;
            this.hall = _data["hall"] ? HallModel.fromJS(_data["hall"]) : <any>undefined;
            this.idCard = _data["idCard"] ? IdCard.fromJS(_data["idCard"]) : <any>undefined;
            this.regionId = _data["regionId"];
            this.region = _data["region"] ? RegionModel.fromJS(_data["region"]) : <any>undefined;
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? CountryModel.fromJS(_data["nationality"]) : <any>undefined;
            this.residentialStatus = _data["residentialStatus"];
            this.guardianName = _data["guardianName"];
            this.guardianPhone = _data["guardianPhone"] ? PhoneNumber.fromJS(_data["guardianPhone"]) : <any>undefined;
            this.guardianOccupation = _data["guardianOccupation"];
            this.guardianRelationship = _data["guardianRelationship"];
            this.disability = _data["disability"];
            this.disabilityType = _data["disabilityType"];
            this.sourceOfFinance = _data["sourceOfFinance"];
            this.religionId = _data["religionId"];
            this.religion = _data["religion"] ? ReligionModel.fromJS(_data["religion"]) : <any>undefined;
            this.denomination = _data["denomination"];
            this.referrals = _data["referrals"];
            this.entryMode = _data["entryMode"];
            this.firstQualification = _data["firstQualification"];
            this.secondQualification = _data["secondQualification"];
            this.programmeStudied = _data["programmeStudied"];
            this.formerSchool = _data["formerSchool"];
            this.formerSchoolNewId = _data["formerSchoolNewId"];
            this.formerSchoolNew = _data["formerSchoolNew"] ? FormerSchoolModel.fromJS(_data["formerSchoolNew"]) : <any>undefined;
            this.programmeAdmittedId = _data["programmeAdmittedId"];
            this.lastYearInSchool = _data["lastYearInSchool"];
            this.awaiting = _data["awaiting"];
            this.indexNo = _data["indexNo"];
            this.grade = _data["grade"];
            this.yearOfAdmission = _data["yearOfAdmission"];
            this.preferredHall = _data["preferredHall"];
            this.results = _data["results"];
            this.externalHostel = _data["externalHostel"];
            this.eligible = _data["eligible"];
            this.admitted = _data["admitted"];
            this.admittedBy = _data["admittedBy"];
            this.dateAdmitted = _data["dateAdmitted"] ? new Date(_data["dateAdmitted"].toString()) : <any>undefined;
            this.admissionType = _data["admissionType"];
            this.levelAdmitted = _data["levelAdmitted"];
            this.sectionAdmitted = _data["sectionAdmitted"];
            this.hallAdmitted = _data["hallAdmitted"];
            this.roomNo = _data["roomNo"];
            this.status = _data["status"];
            this.receivedSms = _data["receivedSms"];
            this.letterPrinted = _data["letterPrinted"];
            this.firstChoiceId = _data["firstChoiceId"];
            this.secondChoiceId = _data["secondChoiceId"];
            this.thirdChoiceId = _data["thirdChoiceId"];
            this.feePaying = _data["feePaying"];
            this.reportedInSchool = _data["reportedInSchool"];
            this.feesPaid = _data["feesPaid"] ? Money.fromJS(_data["feesPaid"]) : <any>undefined;
            this.hallFeesPaid = _data["hallFeesPaid"] ? Money.fromJS(_data["hallFeesPaid"]) : <any>undefined;
            this.reported = _data["reported"];
            this.sponsorShip = _data["sponsorShip"];
            this.sponsorShipCompany = _data["sponsorShipCompany"];
            this.sponsorShipLocation = _data["sponsorShipLocation"];
            this.sponsorShipCompanyContact = _data["sponsorShipCompanyContact"];
            this.applicationUserId = _data["applicationUserId"];
            this.previousIndexNumber = _data["previousIndexNumber"];
            this.getFullName = _data["getFullName"];
            if (Array.isArray(_data["programmes"])) {
                this.programmes = [] as any;
                for (let item of _data["programmes"])
                    this.programmes!.push(ProgrammeModel.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ApplicantModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicantModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationNumber"] = this.applicationNumber ? this.applicationNumber.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["applicantName"] = this.applicantName ? this.applicantName.toJSON() : <any>undefined;
        data["previousName"] = this.previousName ? this.previousName.toJSON() : <any>undefined;
        data["dob"] = this.dob ? formatDate(this.dob) : <any>undefined;
        data["gender"] = this.gender;
        data["age"] = this.age;
        data["maritalStatus"] = this.maritalStatus;
        data["noOfChildren"] = this.noOfChildren;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["altPhone"] = this.altPhone ? this.altPhone.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["emergencyContact"] = this.emergencyContact ? this.emergencyContact.toJSON() : <any>undefined;
        data["hometown"] = this.hometown;
        data["districtId"] = this.districtId;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["hall"] = this.hall ? this.hall.toJSON() : <any>undefined;
        data["idCard"] = this.idCard ? this.idCard.toJSON() : <any>undefined;
        data["regionId"] = this.regionId;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["residentialStatus"] = this.residentialStatus;
        data["guardianName"] = this.guardianName;
        data["guardianPhone"] = this.guardianPhone ? this.guardianPhone.toJSON() : <any>undefined;
        data["guardianOccupation"] = this.guardianOccupation;
        data["guardianRelationship"] = this.guardianRelationship;
        data["disability"] = this.disability;
        data["disabilityType"] = this.disabilityType;
        data["sourceOfFinance"] = this.sourceOfFinance;
        data["religionId"] = this.religionId;
        data["religion"] = this.religion ? this.religion.toJSON() : <any>undefined;
        data["denomination"] = this.denomination;
        data["referrals"] = this.referrals;
        data["entryMode"] = this.entryMode;
        data["firstQualification"] = this.firstQualification;
        data["secondQualification"] = this.secondQualification;
        data["programmeStudied"] = this.programmeStudied;
        data["formerSchool"] = this.formerSchool;
        data["formerSchoolNewId"] = this.formerSchoolNewId;
        data["formerSchoolNew"] = this.formerSchoolNew ? this.formerSchoolNew.toJSON() : <any>undefined;
        data["programmeAdmittedId"] = this.programmeAdmittedId;
        data["lastYearInSchool"] = this.lastYearInSchool;
        data["awaiting"] = this.awaiting;
        data["indexNo"] = this.indexNo;
        data["grade"] = this.grade;
        data["yearOfAdmission"] = this.yearOfAdmission;
        data["preferredHall"] = this.preferredHall;
        data["results"] = this.results;
        data["externalHostel"] = this.externalHostel;
        data["eligible"] = this.eligible;
        data["admitted"] = this.admitted;
        data["admittedBy"] = this.admittedBy;
        data["dateAdmitted"] = this.dateAdmitted ? this.dateAdmitted.toISOString() : <any>undefined;
        data["admissionType"] = this.admissionType;
        data["levelAdmitted"] = this.levelAdmitted;
        data["sectionAdmitted"] = this.sectionAdmitted;
        data["hallAdmitted"] = this.hallAdmitted;
        data["roomNo"] = this.roomNo;
        data["status"] = this.status;
        data["receivedSms"] = this.receivedSms;
        data["letterPrinted"] = this.letterPrinted;
        data["firstChoiceId"] = this.firstChoiceId;
        data["secondChoiceId"] = this.secondChoiceId;
        data["thirdChoiceId"] = this.thirdChoiceId;
        data["feePaying"] = this.feePaying;
        data["reportedInSchool"] = this.reportedInSchool;
        data["feesPaid"] = this.feesPaid ? this.feesPaid.toJSON() : <any>undefined;
        data["hallFeesPaid"] = this.hallFeesPaid ? this.hallFeesPaid.toJSON() : <any>undefined;
        data["reported"] = this.reported;
        data["sponsorShip"] = this.sponsorShip;
        data["sponsorShipCompany"] = this.sponsorShipCompany;
        data["sponsorShipLocation"] = this.sponsorShipLocation;
        data["sponsorShipCompanyContact"] = this.sponsorShipCompanyContact;
        data["applicationUserId"] = this.applicationUserId;
        data["previousIndexNumber"] = this.previousIndexNumber;
        data["getFullName"] = this.getFullName;
        if (Array.isArray(this.programmes)) {
            data["programmes"] = [];
            for (let item of this.programmes)
                data["programmes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IApplicantModel extends IBaseAuditableEntity {
    applicationNumber?: ApplicationNumber | undefined;
    title?: Title;
    applicantName?: ApplicantName | undefined;
    previousName?: ApplicantName | undefined;
    dob?: Date;
    gender?: Gender;
    age?: number;
    maritalStatus?: MaritalStatus | undefined;
    noOfChildren?: number | undefined;
    phone?: PhoneNumber | undefined;
    altPhone?: PhoneNumber | undefined;
    email?: EmailAddress | undefined;
    emergencyContact?: PhoneNumber | undefined;
    hometown?: string | undefined;
    districtId?: number | undefined;
    district?: DistrictModel | undefined;
    hall?: HallModel | undefined;
    idCard?: IdCard | undefined;
    regionId?: number | undefined;
    region?: RegionModel | undefined;
    nationalityId?: number | undefined;
    nationality?: CountryModel | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: PhoneNumber | undefined;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability | undefined;
    sourceOfFinance?: string | undefined;
    religionId?: number | undefined;
    religion?: ReligionModel | undefined;
    denomination?: string | undefined;
    referrals?: string | undefined;
    entryMode?: Session | undefined;
    firstQualification?: EntryQualification | undefined;
    secondQualification?: EntryQualification | undefined;
    programmeStudied?: string | undefined;
    formerSchool?: string | undefined;
    formerSchoolNewId?: number | undefined;
    formerSchoolNew?: FormerSchoolModel | undefined;
    programmeAdmittedId?: number | undefined;
    lastYearInSchool?: number | undefined;
    awaiting?: boolean | undefined;
    indexNo?: string | undefined;
    grade?: number | undefined;
    yearOfAdmission?: string | undefined;
    preferredHall?: string | undefined;
    results?: string | undefined;
    externalHostel?: string | undefined;
    eligible?: boolean | undefined;
    admitted?: boolean | undefined;
    admittedBy?: number | undefined;
    dateAdmitted?: Date | undefined;
    admissionType?: AdmissionType | undefined;
    levelAdmitted?: string | undefined;
    sectionAdmitted?: string | undefined;
    hallAdmitted?: number | undefined;
    roomNo?: string | undefined;
    status?: ApplicationStatus | undefined;
    receivedSms?: boolean | undefined;
    letterPrinted?: boolean | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    feePaying?: boolean | undefined;
    reportedInSchool?: boolean | undefined;
    feesPaid?: Money | undefined;
    hallFeesPaid?: Money | undefined;
    reported?: boolean | undefined;
    sponsorShip?: boolean | undefined;
    sponsorShipCompany?: string | undefined;
    sponsorShipLocation?: string | undefined;
    sponsorShipCompanyContact?: string | undefined;
    applicationUserId?: string | undefined;
    previousIndexNumber?: string | undefined;
    getFullName?: string;
    programmes?: ProgrammeModel[] | undefined;
}

export abstract class ValueObject implements IValueObject {

    constructor(data?: IValueObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ValueObject {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ValueObject' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IValueObject {
}

export class ApplicationNumber extends ValueObject implements IApplicationNumber {
    applicantNumber?: number;

    constructor(data?: IApplicationNumber) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.applicantNumber = _data["applicantNumber"];
        }
    }

    static override fromJS(data: any): ApplicationNumber {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationNumber();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicantNumber"] = this.applicantNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationNumber extends IValueObject {
    applicantNumber?: number;
}

export enum Title {
    Mr = 0,
    Miss = 1,
    Mrs = 2,
    Rev = 3,
    Dr = 4,
    PhD = 5,
    Chief = 6,
    Prof = 7,
}

export class ApplicantName extends ValueObject implements IApplicantName {
    firstName?: string | undefined;
    lastName?: string | undefined;
    othernames?: string | undefined;

    constructor(data?: IApplicantName) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.othernames = _data["othernames"];
        }
    }

    static override fromJS(data: any): ApplicantName {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicantName();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["othernames"] = this.othernames;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicantName extends IValueObject {
    firstName?: string | undefined;
    lastName?: string | undefined;
    othernames?: string | undefined;
}

export enum Gender {
    Male = 0,
    Female = 1,
}

export enum MaritalStatus {
    Married = 0,
    Divorced = 1,
    Single = 2,
    Seperated = 3,
}

export class PhoneNumber extends ValueObject implements IPhoneNumber {
    areaCode?: string | undefined;
    number?: string | undefined;

    constructor(data?: IPhoneNumber) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.areaCode = _data["areaCode"];
            this.number = _data["number"];
        }
    }

    static override fromJS(data: any): PhoneNumber {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumber();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaCode"] = this.areaCode;
        data["number"] = this.number;
        super.toJSON(data);
        return data;
    }
}

export interface IPhoneNumber extends IValueObject {
    areaCode?: string | undefined;
    number?: string | undefined;
}

export class EmailAddress extends ValueObject implements IEmailAddress {
    value?: string | undefined;

    constructor(data?: IEmailAddress) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): EmailAddress {
        data = typeof data === 'object' ? data : {};
        let result = new EmailAddress();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IEmailAddress extends IValueObject {
    value?: string | undefined;
}

export class DistrictModel implements IDistrictModel {
    id?: number;
    name?: string | undefined;
    region?: number | undefined;

    constructor(data?: IDistrictModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): DistrictModel {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["region"] = this.region;
        return data;
    }
}

export interface IDistrictModel {
    id?: number;
    name?: string | undefined;
    region?: number | undefined;
}

export class HallModel implements IHallModel {
    id?: number;
    bankAccount?: number;
    fees?: number;
    name?: string | undefined;

    constructor(data?: IHallModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankAccount = _data["bankAccount"];
            this.fees = _data["fees"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): HallModel {
        data = typeof data === 'object' ? data : {};
        let result = new HallModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccount"] = this.bankAccount;
        data["fees"] = this.fees;
        data["name"] = this.name;
        return data;
    }
}

export interface IHallModel {
    id?: number;
    bankAccount?: number;
    fees?: number;
    name?: string | undefined;
}

export class IdCard extends ValueObject implements IIdCard {
    nationalIDType?: string;
    nationalIDNo?: string;

    constructor(data?: IIdCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nationalIDType = _data["nationalIDType"];
            this.nationalIDNo = _data["nationalIDNo"];
        }
    }

    static override fromJS(data: any): IdCard {
        data = typeof data === 'object' ? data : {};
        let result = new IdCard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nationalIDType"] = this.nationalIDType;
        data["nationalIDNo"] = this.nationalIDNo;
        super.toJSON(data);
        return data;
    }
}

export interface IIdCard extends IValueObject {
    nationalIDType?: string;
    nationalIDNo?: string;
}

export class RegionModel implements IRegionModel {
    id?: number;
    name?: string | undefined;

    constructor(data?: IRegionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RegionModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRegionModel {
    id?: number;
    name?: string | undefined;
}

export class CountryModel implements ICountryModel {
    id?: number;
    name?: string | undefined;

    constructor(data?: ICountryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryModel {
    id?: number;
    name?: string | undefined;
}

export enum Disability {
    Blind = 0,
    Deaf_One_Ear = 1,
    Deaf_Dump = 2,
    Amputee = 3,
    Normal = 4,
    Crippled = 5,
    Blind_One_Eye = 6,
    Deaf = 7,
}

export class ReligionModel implements IReligionModel {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IReligionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ReligionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReligionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IReligionModel {
    id?: number | undefined;
    name?: string | undefined;
}

export enum Session {
    Regular = 0,
    Evening = 1,
    Sandwich = 2,
    Session = 3,
}

export enum EntryQualification {
    WASSCE = 0,
    SSCE = 1,
    NVTI = 2,
    DEGREE = 3,
    MASTERS = 4,
    HND = 5,
    DIPLOMA = 6,
    BECE = 7,
    PhD = 8,
}

export class FormerSchoolModel implements IFormerSchoolModel {
    id?: number;
    name?: string | undefined;
    location?: string | undefined;
    region?: number;

    constructor(data?: IFormerSchoolModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.location = _data["location"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): FormerSchoolModel {
        data = typeof data === 'object' ? data : {};
        let result = new FormerSchoolModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["location"] = this.location;
        data["region"] = this.region;
        return data;
    }
}

export interface IFormerSchoolModel {
    id?: number;
    name?: string | undefined;
    location?: string | undefined;
    region?: number;
}

export enum AdmissionType {
    Mature = 0,
    Regular = 1,
    Access = 2,
    Conditional = 3,
}

export enum ApplicationStatus {
    Admitted = 0,
    Applicant = 1,
    Reported = 2,
    FeePaid = 3,
}

export class Money extends ValueObject implements IMoney {
    currency?: string;
    amount?: number;

    constructor(data?: IMoney) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.currency = _data["currency"];
            this.amount = _data["amount"];
        }
    }

    static override fromJS(data: any): Money {
        data = typeof data === 'object' ? data : {};
        let result = new Money();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        super.toJSON(data);
        return data;
    }
}

export interface IMoney extends IValueObject {
    currency?: string;
    amount?: number;
}

export class ProgrammeModel implements IProgrammeModel {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    levelAdmitted?: string | undefined;
    running?: boolean;
    showOnPortal?: boolean;
    type?: string | undefined;
    duration?: number;
    department?: DepartmentModel | undefined;
    affiliation?: string | undefined;
    applicant?: ApplicantModel[] | undefined;

    constructor(data?: IProgrammeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.levelAdmitted = _data["levelAdmitted"];
            this.running = _data["running"];
            this.showOnPortal = _data["showOnPortal"];
            this.type = _data["type"];
            this.duration = _data["duration"];
            this.department = _data["department"] ? DepartmentModel.fromJS(_data["department"]) : <any>undefined;
            this.affiliation = _data["affiliation"];
            if (Array.isArray(_data["applicant"])) {
                this.applicant = [] as any;
                for (let item of _data["applicant"])
                    this.applicant!.push(ApplicantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgrammeModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProgrammeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["levelAdmitted"] = this.levelAdmitted;
        data["running"] = this.running;
        data["showOnPortal"] = this.showOnPortal;
        data["type"] = this.type;
        data["duration"] = this.duration;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["affiliation"] = this.affiliation;
        if (Array.isArray(this.applicant)) {
            data["applicant"] = [];
            for (let item of this.applicant)
                data["applicant"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProgrammeModel {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    levelAdmitted?: string | undefined;
    running?: boolean;
    showOnPortal?: boolean;
    type?: string | undefined;
    duration?: number;
    department?: DepartmentModel | undefined;
    affiliation?: string | undefined;
    applicant?: ApplicantModel[] | undefined;
}

export class DepartmentModel implements IDepartmentModel {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    faculty?: FacultyModel | undefined;

    constructor(data?: IDepartmentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.faculty = _data["faculty"] ? FacultyModel.fromJS(_data["faculty"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DepartmentModel {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["faculty"] = this.faculty ? this.faculty.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDepartmentModel {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    faculty?: FacultyModel | undefined;
}

export class FacultyModel implements IFacultyModel {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IFacultyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): FacultyModel {
        data = typeof data === 'object' ? data : {};
        let result = new FacultyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IFacultyModel {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
}

export abstract class BaseEvent implements IBaseEvent {

    constructor(data?: IBaseEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BaseEvent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEvent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IBaseEvent {
}

export class CreateAddressRequest implements ICreateAddressRequest {
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;

    constructor(data?: ICreateAddressRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.street = _data["street"];
            this.houseNumber = _data["houseNumber"];
            this.city = _data["city"];
            this.gprs = _data["gprs"];
            this.box = _data["box"];
        }
    }

    static fromJS(data: any): CreateAddressRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAddressRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["street"] = this.street;
        data["houseNumber"] = this.houseNumber;
        data["city"] = this.city;
        data["gprs"] = this.gprs;
        data["box"] = this.box;
        return data;
    }
}

export interface ICreateAddressRequest {
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;
}

export class ApplicantVm implements IApplicantVm {
    id?: number;
    applicationNumber?: ApplicationNumber | undefined;
    title?: Title;
    applicantName?: ApplicantName | undefined;
    previousName?: ApplicantName | undefined;
    dob?: Date;
    gender?: Gender;
    age?: number;
    maritalStatus?: MaritalStatus | undefined;
    noOfChildren?: number | undefined;
    phone?: PhoneNumber | undefined;
    altPhone?: PhoneNumber | undefined;
    email?: EmailAddress | undefined;
    postGprs?: string | undefined;
    emergencyContact?: PhoneNumber | undefined;
    hometown?: string | undefined;
    districtId?: number | undefined;
    district?: DistrictModel | undefined;
    hall?: HallModel | undefined;
    idcard?: IdCard | undefined;
    regionId?: number | undefined;
    region?: RegionModel | undefined;
    nationalityId?: number | undefined;
    nationality?: CountryModel | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: PhoneNumber | undefined;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability | undefined;
    sourceOfFinance?: string | undefined;
    religionId?: number | undefined;
    religion?: ReligionModel | undefined;
    denomination?: string | undefined;
    referrals?: string | undefined;
    entryMode?: string | undefined;
    firstQualification?: string | undefined;
    secondQualification?: string | undefined;
    programmeStudied?: string | undefined;
    formerSchool?: string | undefined;
    formerSchoolNewId?: number | undefined;
    programmeAdmittedId?: number | undefined;
    lastYearInSchool?: number | undefined;
    awaiting?: boolean | undefined;
    indexNo?: string | undefined;
    grade?: number | undefined;
    preferedHall?: string | undefined;
    elligible?: boolean | undefined;
    admitted?: boolean | undefined;
    admittedBy?: number | undefined;
    admissionType?: string | undefined;
    leveladmitted?: string | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    sponsorShip?: boolean | undefined;
    sponsorShipCompany?: string | undefined;
    sponsorShipLocation?: string | undefined;
    sponsorShipCompanyContact?: string | undefined;
    getFullName?: string;
    programmes?: ProgrammeModel[] | undefined;
    resultUploads?: ResultUploadModel[] | undefined;
    workingExperiences?: WorkingExperienceModel[] | undefined;
    academicExperiences?: AcademicExperienceModel[] | undefined;
    documents?: DocumentUploadModel[] | undefined;
    referees?: RefereeModel[] | undefined;
    addresses?: AddressModel[] | undefined;
    languages?: LanguageModel[] | undefined;
    sms?: SmsModel[] | undefined;
    researchModels?: ResearchModel[] | undefined;
    researchPublications?: ResearchPublicationModel[] | undefined;
    universityAttended?: UniversityAttendedModel[] | undefined;
    shsAttended?: SHSAttendedModel[] | undefined;
    disabilities?: DisabilitiesModel[] | undefined;

    constructor(data?: IApplicantVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicationNumber = _data["applicationNumber"] ? ApplicationNumber.fromJS(_data["applicationNumber"]) : <any>undefined;
            this.title = _data["title"];
            this.applicantName = _data["applicantName"] ? ApplicantName.fromJS(_data["applicantName"]) : <any>undefined;
            this.previousName = _data["previousName"] ? ApplicantName.fromJS(_data["previousName"]) : <any>undefined;
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.age = _data["age"];
            this.maritalStatus = _data["maritalStatus"];
            this.noOfChildren = _data["noOfChildren"];
            this.phone = _data["phone"] ? PhoneNumber.fromJS(_data["phone"]) : <any>undefined;
            this.altPhone = _data["altPhone"] ? PhoneNumber.fromJS(_data["altPhone"]) : <any>undefined;
            this.email = _data["email"] ? EmailAddress.fromJS(_data["email"]) : <any>undefined;
            this.postGprs = _data["postGprs"];
            this.emergencyContact = _data["emergencyContact"] ? PhoneNumber.fromJS(_data["emergencyContact"]) : <any>undefined;
            this.hometown = _data["hometown"];
            this.districtId = _data["districtId"];
            this.district = _data["district"] ? DistrictModel.fromJS(_data["district"]) : <any>undefined;
            this.hall = _data["hall"] ? HallModel.fromJS(_data["hall"]) : <any>undefined;
            this.idcard = _data["idcard"] ? IdCard.fromJS(_data["idcard"]) : <any>undefined;
            this.regionId = _data["regionId"];
            this.region = _data["region"] ? RegionModel.fromJS(_data["region"]) : <any>undefined;
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? CountryModel.fromJS(_data["nationality"]) : <any>undefined;
            this.residentialStatus = _data["residentialStatus"];
            this.guardianName = _data["guardianName"];
            this.guardianPhone = _data["guardianPhone"] ? PhoneNumber.fromJS(_data["guardianPhone"]) : <any>undefined;
            this.guardianOccupation = _data["guardianOccupation"];
            this.guardianRelationship = _data["guardianRelationship"];
            this.disability = _data["disability"];
            this.disabilityType = _data["disabilityType"];
            this.sourceOfFinance = _data["sourceOfFinance"];
            this.religionId = _data["religionId"];
            this.religion = _data["religion"] ? ReligionModel.fromJS(_data["religion"]) : <any>undefined;
            this.denomination = _data["denomination"];
            this.referrals = _data["referrals"];
            this.entryMode = _data["entryMode"];
            this.firstQualification = _data["firstQualification"];
            this.secondQualification = _data["secondQualification"];
            this.programmeStudied = _data["programmeStudied"];
            this.formerSchool = _data["formerSchool"];
            this.formerSchoolNewId = _data["formerSchoolNewId"];
            this.programmeAdmittedId = _data["programmeAdmittedId"];
            this.lastYearInSchool = _data["lastYearInSchool"];
            this.awaiting = _data["awaiting"];
            this.indexNo = _data["indexNo"];
            this.grade = _data["grade"];
            this.preferedHall = _data["preferedHall"];
            this.elligible = _data["elligible"];
            this.admitted = _data["admitted"];
            this.admittedBy = _data["admittedBy"];
            this.admissionType = _data["admissionType"];
            this.leveladmitted = _data["leveladmitted"];
            this.firstChoiceId = _data["firstChoiceId"];
            this.secondChoiceId = _data["secondChoiceId"];
            this.thirdChoiceId = _data["thirdChoiceId"];
            this.sponsorShip = _data["sponsorShip"];
            this.sponsorShipCompany = _data["sponsorShipCompany"];
            this.sponsorShipLocation = _data["sponsorShipLocation"];
            this.sponsorShipCompanyContact = _data["sponsorShipCompanyContact"];
            this.getFullName = _data["getFullName"];
            if (Array.isArray(_data["programmes"])) {
                this.programmes = [] as any;
                for (let item of _data["programmes"])
                    this.programmes!.push(ProgrammeModel.fromJS(item));
            }
            if (Array.isArray(_data["resultUploads"])) {
                this.resultUploads = [] as any;
                for (let item of _data["resultUploads"])
                    this.resultUploads!.push(ResultUploadModel.fromJS(item));
            }
            if (Array.isArray(_data["workingExperiences"])) {
                this.workingExperiences = [] as any;
                for (let item of _data["workingExperiences"])
                    this.workingExperiences!.push(WorkingExperienceModel.fromJS(item));
            }
            if (Array.isArray(_data["academicExperiences"])) {
                this.academicExperiences = [] as any;
                for (let item of _data["academicExperiences"])
                    this.academicExperiences!.push(AcademicExperienceModel.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentUploadModel.fromJS(item));
            }
            if (Array.isArray(_data["referees"])) {
                this.referees = [] as any;
                for (let item of _data["referees"])
                    this.referees!.push(RefereeModel.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(AddressModel.fromJS(item));
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageModel.fromJS(item));
            }
            if (Array.isArray(_data["sms"])) {
                this.sms = [] as any;
                for (let item of _data["sms"])
                    this.sms!.push(SmsModel.fromJS(item));
            }
            if (Array.isArray(_data["researchModels"])) {
                this.researchModels = [] as any;
                for (let item of _data["researchModels"])
                    this.researchModels!.push(ResearchModel.fromJS(item));
            }
            if (Array.isArray(_data["researchPublications"])) {
                this.researchPublications = [] as any;
                for (let item of _data["researchPublications"])
                    this.researchPublications!.push(ResearchPublicationModel.fromJS(item));
            }
            if (Array.isArray(_data["universityAttended"])) {
                this.universityAttended = [] as any;
                for (let item of _data["universityAttended"])
                    this.universityAttended!.push(UniversityAttendedModel.fromJS(item));
            }
            if (Array.isArray(_data["shsAttended"])) {
                this.shsAttended = [] as any;
                for (let item of _data["shsAttended"])
                    this.shsAttended!.push(SHSAttendedModel.fromJS(item));
            }
            if (Array.isArray(_data["disabilities"])) {
                this.disabilities = [] as any;
                for (let item of _data["disabilities"])
                    this.disabilities!.push(DisabilitiesModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicantVm {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicantVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicationNumber"] = this.applicationNumber ? this.applicationNumber.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["applicantName"] = this.applicantName ? this.applicantName.toJSON() : <any>undefined;
        data["previousName"] = this.previousName ? this.previousName.toJSON() : <any>undefined;
        data["dob"] = this.dob ? formatDate(this.dob) : <any>undefined;
        data["gender"] = this.gender;
        data["age"] = this.age;
        data["maritalStatus"] = this.maritalStatus;
        data["noOfChildren"] = this.noOfChildren;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["altPhone"] = this.altPhone ? this.altPhone.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["postGprs"] = this.postGprs;
        data["emergencyContact"] = this.emergencyContact ? this.emergencyContact.toJSON() : <any>undefined;
        data["hometown"] = this.hometown;
        data["districtId"] = this.districtId;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["hall"] = this.hall ? this.hall.toJSON() : <any>undefined;
        data["idcard"] = this.idcard ? this.idcard.toJSON() : <any>undefined;
        data["regionId"] = this.regionId;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["residentialStatus"] = this.residentialStatus;
        data["guardianName"] = this.guardianName;
        data["guardianPhone"] = this.guardianPhone ? this.guardianPhone.toJSON() : <any>undefined;
        data["guardianOccupation"] = this.guardianOccupation;
        data["guardianRelationship"] = this.guardianRelationship;
        data["disability"] = this.disability;
        data["disabilityType"] = this.disabilityType;
        data["sourceOfFinance"] = this.sourceOfFinance;
        data["religionId"] = this.religionId;
        data["religion"] = this.religion ? this.religion.toJSON() : <any>undefined;
        data["denomination"] = this.denomination;
        data["referrals"] = this.referrals;
        data["entryMode"] = this.entryMode;
        data["firstQualification"] = this.firstQualification;
        data["secondQualification"] = this.secondQualification;
        data["programmeStudied"] = this.programmeStudied;
        data["formerSchool"] = this.formerSchool;
        data["formerSchoolNewId"] = this.formerSchoolNewId;
        data["programmeAdmittedId"] = this.programmeAdmittedId;
        data["lastYearInSchool"] = this.lastYearInSchool;
        data["awaiting"] = this.awaiting;
        data["indexNo"] = this.indexNo;
        data["grade"] = this.grade;
        data["preferedHall"] = this.preferedHall;
        data["elligible"] = this.elligible;
        data["admitted"] = this.admitted;
        data["admittedBy"] = this.admittedBy;
        data["admissionType"] = this.admissionType;
        data["leveladmitted"] = this.leveladmitted;
        data["firstChoiceId"] = this.firstChoiceId;
        data["secondChoiceId"] = this.secondChoiceId;
        data["thirdChoiceId"] = this.thirdChoiceId;
        data["sponsorShip"] = this.sponsorShip;
        data["sponsorShipCompany"] = this.sponsorShipCompany;
        data["sponsorShipLocation"] = this.sponsorShipLocation;
        data["sponsorShipCompanyContact"] = this.sponsorShipCompanyContact;
        data["getFullName"] = this.getFullName;
        if (Array.isArray(this.programmes)) {
            data["programmes"] = [];
            for (let item of this.programmes)
                data["programmes"].push(item.toJSON());
        }
        if (Array.isArray(this.resultUploads)) {
            data["resultUploads"] = [];
            for (let item of this.resultUploads)
                data["resultUploads"].push(item.toJSON());
        }
        if (Array.isArray(this.workingExperiences)) {
            data["workingExperiences"] = [];
            for (let item of this.workingExperiences)
                data["workingExperiences"].push(item.toJSON());
        }
        if (Array.isArray(this.academicExperiences)) {
            data["academicExperiences"] = [];
            for (let item of this.academicExperiences)
                data["academicExperiences"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.referees)) {
            data["referees"] = [];
            for (let item of this.referees)
                data["referees"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.sms)) {
            data["sms"] = [];
            for (let item of this.sms)
                data["sms"].push(item.toJSON());
        }
        if (Array.isArray(this.researchModels)) {
            data["researchModels"] = [];
            for (let item of this.researchModels)
                data["researchModels"].push(item.toJSON());
        }
        if (Array.isArray(this.researchPublications)) {
            data["researchPublications"] = [];
            for (let item of this.researchPublications)
                data["researchPublications"].push(item.toJSON());
        }
        if (Array.isArray(this.universityAttended)) {
            data["universityAttended"] = [];
            for (let item of this.universityAttended)
                data["universityAttended"].push(item.toJSON());
        }
        if (Array.isArray(this.shsAttended)) {
            data["shsAttended"] = [];
            for (let item of this.shsAttended)
                data["shsAttended"].push(item.toJSON());
        }
        if (Array.isArray(this.disabilities)) {
            data["disabilities"] = [];
            for (let item of this.disabilities)
                data["disabilities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApplicantVm {
    id?: number;
    applicationNumber?: ApplicationNumber | undefined;
    title?: Title;
    applicantName?: ApplicantName | undefined;
    previousName?: ApplicantName | undefined;
    dob?: Date;
    gender?: Gender;
    age?: number;
    maritalStatus?: MaritalStatus | undefined;
    noOfChildren?: number | undefined;
    phone?: PhoneNumber | undefined;
    altPhone?: PhoneNumber | undefined;
    email?: EmailAddress | undefined;
    postGprs?: string | undefined;
    emergencyContact?: PhoneNumber | undefined;
    hometown?: string | undefined;
    districtId?: number | undefined;
    district?: DistrictModel | undefined;
    hall?: HallModel | undefined;
    idcard?: IdCard | undefined;
    regionId?: number | undefined;
    region?: RegionModel | undefined;
    nationalityId?: number | undefined;
    nationality?: CountryModel | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: PhoneNumber | undefined;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability | undefined;
    sourceOfFinance?: string | undefined;
    religionId?: number | undefined;
    religion?: ReligionModel | undefined;
    denomination?: string | undefined;
    referrals?: string | undefined;
    entryMode?: string | undefined;
    firstQualification?: string | undefined;
    secondQualification?: string | undefined;
    programmeStudied?: string | undefined;
    formerSchool?: string | undefined;
    formerSchoolNewId?: number | undefined;
    programmeAdmittedId?: number | undefined;
    lastYearInSchool?: number | undefined;
    awaiting?: boolean | undefined;
    indexNo?: string | undefined;
    grade?: number | undefined;
    preferedHall?: string | undefined;
    elligible?: boolean | undefined;
    admitted?: boolean | undefined;
    admittedBy?: number | undefined;
    admissionType?: string | undefined;
    leveladmitted?: string | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    sponsorShip?: boolean | undefined;
    sponsorShipCompany?: string | undefined;
    sponsorShipLocation?: string | undefined;
    sponsorShipCompanyContact?: string | undefined;
    getFullName?: string;
    programmes?: ProgrammeModel[] | undefined;
    resultUploads?: ResultUploadModel[] | undefined;
    workingExperiences?: WorkingExperienceModel[] | undefined;
    academicExperiences?: AcademicExperienceModel[] | undefined;
    documents?: DocumentUploadModel[] | undefined;
    referees?: RefereeModel[] | undefined;
    addresses?: AddressModel[] | undefined;
    languages?: LanguageModel[] | undefined;
    sms?: SmsModel[] | undefined;
    researchModels?: ResearchModel[] | undefined;
    researchPublications?: ResearchPublicationModel[] | undefined;
    universityAttended?: UniversityAttendedModel[] | undefined;
    shsAttended?: SHSAttendedModel[] | undefined;
    disabilities?: DisabilitiesModel[] | undefined;
}

export class ResultUploadModel extends BaseEntity implements IResultUploadModel {
    subjectId?: number;
    examType?: string | undefined;
    gradeId?: number;
    gradeOld?: number | undefined;
    gradeValueOld?: string | undefined;
    indexNo?: string | undefined;
    sitting?: string | undefined;
    month?: string | undefined;
    form?: number;
    center?: string | undefined;
    year?: string | undefined;
    oldSubject?: string | undefined;
    institutionName?: string | undefined;
    applicantModelId?: number;
    applicantModel?: ApplicantModel | undefined;
    subject?: SubjectModel | undefined;
    grade?: GradeModel | undefined;

    constructor(data?: IResultUploadModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.subjectId = _data["subjectId"];
            this.examType = _data["examType"];
            this.gradeId = _data["gradeId"];
            this.gradeOld = _data["gradeOld"];
            this.gradeValueOld = _data["gradeValueOld"];
            this.indexNo = _data["indexNo"];
            this.sitting = _data["sitting"];
            this.month = _data["month"];
            this.form = _data["form"];
            this.center = _data["center"];
            this.year = _data["year"];
            this.oldSubject = _data["oldSubject"];
            this.institutionName = _data["institutionName"];
            this.applicantModelId = _data["applicantModelId"];
            this.applicantModel = _data["applicantModel"] ? ApplicantModel.fromJS(_data["applicantModel"]) : <any>undefined;
            this.subject = _data["subject"] ? SubjectModel.fromJS(_data["subject"]) : <any>undefined;
            this.grade = _data["grade"] ? GradeModel.fromJS(_data["grade"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ResultUploadModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultUploadModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectId"] = this.subjectId;
        data["examType"] = this.examType;
        data["gradeId"] = this.gradeId;
        data["gradeOld"] = this.gradeOld;
        data["gradeValueOld"] = this.gradeValueOld;
        data["indexNo"] = this.indexNo;
        data["sitting"] = this.sitting;
        data["month"] = this.month;
        data["form"] = this.form;
        data["center"] = this.center;
        data["year"] = this.year;
        data["oldSubject"] = this.oldSubject;
        data["institutionName"] = this.institutionName;
        data["applicantModelId"] = this.applicantModelId;
        data["applicantModel"] = this.applicantModel ? this.applicantModel.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IResultUploadModel extends IBaseEntity {
    subjectId?: number;
    examType?: string | undefined;
    gradeId?: number;
    gradeOld?: number | undefined;
    gradeValueOld?: string | undefined;
    indexNo?: string | undefined;
    sitting?: string | undefined;
    month?: string | undefined;
    form?: number;
    center?: string | undefined;
    year?: string | undefined;
    oldSubject?: string | undefined;
    institutionName?: string | undefined;
    applicantModelId?: number;
    applicantModel?: ApplicantModel | undefined;
    subject?: SubjectModel | undefined;
    grade?: GradeModel | undefined;
}

export class SubjectModel implements ISubjectModel {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    type?: string | undefined;

    constructor(data?: ISubjectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SubjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["type"] = this.type;
        return data;
    }
}

export interface ISubjectModel {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    type?: string | undefined;
}

export class GradeModel implements IGradeModel {
    id?: number;
    name?: string | undefined;
    value?: number;
    comment?: string | undefined;
    exam?: number;

    constructor(data?: IGradeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.comment = _data["comment"];
            this.exam = _data["exam"];
        }
    }

    static fromJS(data: any): GradeModel {
        data = typeof data === 'object' ? data : {};
        let result = new GradeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["comment"] = this.comment;
        data["exam"] = this.exam;
        return data;
    }
}

export interface IGradeModel {
    id?: number;
    name?: string | undefined;
    value?: number;
    comment?: string | undefined;
    exam?: number;
}

export class WorkingExperienceModel extends BaseEntity implements IWorkingExperienceModel {
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyAddress?: string | undefined;
    companyPosition?: string | undefined;
    companyFrom?: string | undefined;
    companyTo?: string | undefined;
    applicantModel?: ApplicantModel | undefined;

    constructor(data?: IWorkingExperienceModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.companyName = _data["companyName"];
            this.companyPhone = _data["companyPhone"];
            this.companyAddress = _data["companyAddress"];
            this.companyPosition = _data["companyPosition"];
            this.companyFrom = _data["companyFrom"];
            this.companyTo = _data["companyTo"];
            this.applicantModel = _data["applicantModel"] ? ApplicantModel.fromJS(_data["applicantModel"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): WorkingExperienceModel {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingExperienceModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["companyPhone"] = this.companyPhone;
        data["companyAddress"] = this.companyAddress;
        data["companyPosition"] = this.companyPosition;
        data["companyFrom"] = this.companyFrom;
        data["companyTo"] = this.companyTo;
        data["applicantModel"] = this.applicantModel ? this.applicantModel.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IWorkingExperienceModel extends IBaseEntity {
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyAddress?: string | undefined;
    companyPosition?: string | undefined;
    companyFrom?: string | undefined;
    companyTo?: string | undefined;
    applicantModel?: ApplicantModel | undefined;
}

export class AcademicExperienceModel extends BaseAuditableEntity implements IAcademicExperienceModel {
    institutionName?: string | undefined;
    institutionAddress?: string | undefined;
    programmeStudied?: string | undefined;
    from?: Date;
    to?: Date;
    certificate?: string | undefined;
    applicantModelId?: number;
    applicantModel?: ApplicantModel | undefined;

    constructor(data?: IAcademicExperienceModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.institutionName = _data["institutionName"];
            this.institutionAddress = _data["institutionAddress"];
            this.programmeStudied = _data["programmeStudied"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            this.certificate = _data["certificate"];
            this.applicantModelId = _data["applicantModelId"];
            this.applicantModel = _data["applicantModel"] ? ApplicantModel.fromJS(_data["applicantModel"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AcademicExperienceModel {
        data = typeof data === 'object' ? data : {};
        let result = new AcademicExperienceModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["institutionName"] = this.institutionName;
        data["institutionAddress"] = this.institutionAddress;
        data["programmeStudied"] = this.programmeStudied;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["certificate"] = this.certificate;
        data["applicantModelId"] = this.applicantModelId;
        data["applicantModel"] = this.applicantModel ? this.applicantModel.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAcademicExperienceModel extends IBaseAuditableEntity {
    institutionName?: string | undefined;
    institutionAddress?: string | undefined;
    programmeStudied?: string | undefined;
    from?: Date;
    to?: Date;
    certificate?: string | undefined;
    applicantModelId?: number;
    applicantModel?: ApplicantModel | undefined;
}

export class DocumentUploadModel extends BaseAuditableEntity implements IDocumentUploadModel {
    applicant?: ApplicantModel | undefined;
    name?: string | undefined;
    type?: string | undefined;

    constructor(data?: IDocumentUploadModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): DocumentUploadModel {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentUploadModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IDocumentUploadModel extends IBaseAuditableEntity {
    applicant?: ApplicantModel | undefined;
    name?: string | undefined;
    type?: string | undefined;
}

export class RefereeModel extends BaseAuditableEntity implements IRefereeModel {
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicantModel?: ApplicantModel | undefined;
    refereeStatus?: RefereeStatus;

    constructor(data?: IRefereeModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.institution = _data["institution"];
            this.email = _data["email"];
            this.position = _data["position"];
            this.applicantModel = _data["applicantModel"] ? ApplicantModel.fromJS(_data["applicantModel"]) : <any>undefined;
            this.refereeStatus = _data["refereeStatus"];
        }
    }

    static override fromJS(data: any): RefereeModel {
        data = typeof data === 'object' ? data : {};
        let result = new RefereeModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["institution"] = this.institution;
        data["email"] = this.email;
        data["position"] = this.position;
        data["applicantModel"] = this.applicantModel ? this.applicantModel.toJSON() : <any>undefined;
        data["refereeStatus"] = this.refereeStatus;
        super.toJSON(data);
        return data;
    }
}

export interface IRefereeModel extends IBaseAuditableEntity {
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicantModel?: ApplicantModel | undefined;
    refereeStatus?: RefereeStatus;
}

export enum RefereeStatus {
    Approved = 0,
    Pending = 1,
    Declined = 2,
}

export class AddressModel implements IAddressModel {
    id?: number;
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;
    applicant?: ApplicantModel | undefined;

    constructor(data?: IAddressModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.street = _data["street"];
            this.houseNumber = _data["houseNumber"];
            this.city = _data["city"];
            this.gprs = _data["gprs"];
            this.box = _data["box"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddressModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddressModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["street"] = this.street;
        data["houseNumber"] = this.houseNumber;
        data["city"] = this.city;
        data["gprs"] = this.gprs;
        data["box"] = this.box;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddressModel {
    id?: number;
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;
    applicant?: ApplicantModel | undefined;
}

export class LanguageModel implements ILanguageModel {
    id?: number;
    name?: string | undefined;
    applicant?: number;

    constructor(data?: ILanguageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): LanguageModel {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface ILanguageModel {
    id?: number;
    name?: string | undefined;
    applicant?: number;
}

export class SmsModel implements ISmsModel {
    id?: number;
    message?: string | undefined;
    sentBy?: string | undefined;
    recipient?: number;
    dateSent?: Date;
    status?: string | undefined;
    applicant?: number | undefined;

    constructor(data?: ISmsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.message = _data["message"];
            this.sentBy = _data["sentBy"];
            this.recipient = _data["recipient"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): SmsModel {
        data = typeof data === 'object' ? data : {};
        let result = new SmsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["message"] = this.message;
        data["sentBy"] = this.sentBy;
        data["recipient"] = this.recipient;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface ISmsModel {
    id?: number;
    message?: string | undefined;
    sentBy?: string | undefined;
    recipient?: number;
    dateSent?: Date;
    status?: string | undefined;
    applicant?: number | undefined;
}

export class ResearchModel implements IResearchModel {
    id?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;
    applicant?: ApplicantModel | undefined;

    constructor(data?: IResearchModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.month = _data["month"];
            this.areaOfResearchIfAdmitted = _data["areaOfResearchIfAdmitted"];
            this.actualAreaOfResearch = _data["actualAreaOfResearch"];
            this.futureResearchInterest = _data["futureResearchInterest"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResearchModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["month"] = this.month;
        data["areaOfResearchIfAdmitted"] = this.areaOfResearchIfAdmitted;
        data["actualAreaOfResearch"] = this.actualAreaOfResearch;
        data["futureResearchInterest"] = this.futureResearchInterest;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResearchModel {
    id?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;
    applicant?: ApplicantModel | undefined;
}

export class ResearchPublicationModel implements IResearchPublicationModel {
    id?: number;
    applicant?: ApplicantModel | undefined;
    publication?: string | undefined;

    constructor(data?: IResearchPublicationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
            this.publication = _data["publication"];
        }
    }

    static fromJS(data: any): ResearchPublicationModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchPublicationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        data["publication"] = this.publication;
        return data;
    }
}

export interface IResearchPublicationModel {
    id?: number;
    applicant?: ApplicantModel | undefined;
    publication?: string | undefined;
}

export class UniversityAttendedModel implements IUniversityAttendedModel {
    id?: number;
    name?: string | undefined;
    location?: CountryModel | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;
    studentNumber?: string | undefined;
    degreeObtained?: string | undefined;
    degreeClassification?: string | undefined;
    cgpa?: number | undefined;
    applicant?: ApplicantModel | undefined;

    constructor(data?: IUniversityAttendedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.location = _data["location"] ? CountryModel.fromJS(_data["location"]) : <any>undefined;
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
            this.studentNumber = _data["studentNumber"];
            this.degreeObtained = _data["degreeObtained"];
            this.degreeClassification = _data["degreeClassification"];
            this.cgpa = _data["cgpa"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UniversityAttendedModel {
        data = typeof data === 'object' ? data : {};
        let result = new UniversityAttendedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        data["studentNumber"] = this.studentNumber;
        data["degreeObtained"] = this.degreeObtained;
        data["degreeClassification"] = this.degreeClassification;
        data["cgpa"] = this.cgpa;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUniversityAttendedModel {
    id?: number;
    name?: string | undefined;
    location?: CountryModel | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;
    studentNumber?: string | undefined;
    degreeObtained?: string | undefined;
    degreeClassification?: string | undefined;
    cgpa?: number | undefined;
    applicant?: ApplicantModel | undefined;
}

export class SHSAttendedModel implements ISHSAttendedModel {
    id?: number;
    attendedTTU?: boolean;
    applicant?: ApplicantModel | undefined;
    name?: FormerSchoolModel | undefined;
    location?: RegionModel | undefined;
    startYear?: number | undefined;
    endYear?: number | undefined;
    programmeStudied?: string | undefined;

    constructor(data?: ISHSAttendedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.attendedTTU = _data["attendedTTU"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
            this.name = _data["name"] ? FormerSchoolModel.fromJS(_data["name"]) : <any>undefined;
            this.location = _data["location"] ? RegionModel.fromJS(_data["location"]) : <any>undefined;
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
            this.programmeStudied = _data["programmeStudied"];
        }
    }

    static fromJS(data: any): SHSAttendedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SHSAttendedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attendedTTU"] = this.attendedTTU;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        data["programmeStudied"] = this.programmeStudied;
        return data;
    }
}

export interface ISHSAttendedModel {
    id?: number;
    attendedTTU?: boolean;
    applicant?: ApplicantModel | undefined;
    name?: FormerSchoolModel | undefined;
    location?: RegionModel | undefined;
    startYear?: number | undefined;
    endYear?: number | undefined;
    programmeStudied?: string | undefined;
}

export class DisabilitiesModel implements IDisabilitiesModel {
    id?: number;
    name?: string | undefined;
    applicantModelId?: number | undefined;

    constructor(data?: IDisabilitiesModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.applicantModelId = _data["applicantModelId"];
        }
    }

    static fromJS(data: any): DisabilitiesModel {
        data = typeof data === 'object' ? data : {};
        let result = new DisabilitiesModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["applicantModelId"] = this.applicantModelId;
        return data;
    }
}

export interface IDisabilitiesModel {
    id?: number;
    name?: string | undefined;
    applicantModelId?: number | undefined;
}

export enum ApplicationType {
    Certificate = 0,
    Bridging = 1,
    Diploma = 2,
    Hnd = 3,
    Topup = 4,
    Degree = 5,
    Masters = 6,
    PhD = 7,
}

export abstract class CreateFormUpdateRequest implements ICreateFormUpdateRequest {
    formType?: ApplicationType;

    constructor(data?: ICreateFormUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formType = _data["formType"];
        }
    }

    static fromJS(data: any): CreateFormUpdateRequest {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CreateFormUpdateRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formType"] = this.formType;
        return data;
    }
}

export interface ICreateFormUpdateRequest {
    formType?: ApplicationType;
}

export class CreateBiodataRequest implements ICreateBiodataRequest {
    id?: number | undefined;
    applicationNumber?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    otherName?: string | undefined;
    previousName?: string | undefined;
    noOfChildren?: number | undefined;
    gender?: Gender;
    dateOfBirth?: Date;
    month?: string | undefined;
    year?: string | undefined;
    day?: string | undefined;
    title?: Title;
    maritalStatus?: MaritalStatus | undefined;
    phone?: string | undefined;
    altPhone?: string | undefined;
    email?: string | undefined;
    emergencyContact?: string | undefined;
    hometown?: string | undefined;
    district?: number | undefined;
    regionId?: number | undefined;
    nationalityId?: number | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: string | undefined;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability[] | undefined;
    religionId?: number;
    denomination?: string | undefined;
    idCard?: IdCards;
    referrals?: string | undefined;
    nationalIDNo?: string | undefined;
    languages?: Languages[] | undefined;

    constructor(data?: ICreateBiodataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicationNumber = _data["applicationNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherName = _data["otherName"];
            this.previousName = _data["previousName"];
            this.noOfChildren = _data["noOfChildren"];
            this.gender = _data["gender"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.month = _data["month"];
            this.year = _data["year"];
            this.day = _data["day"];
            this.title = _data["title"];
            this.maritalStatus = _data["maritalStatus"];
            this.phone = _data["phone"];
            this.altPhone = _data["altPhone"];
            this.email = _data["email"];
            this.emergencyContact = _data["emergencyContact"];
            this.hometown = _data["hometown"];
            this.district = _data["district"];
            this.regionId = _data["regionId"];
            this.nationalityId = _data["nationalityId"];
            this.residentialStatus = _data["residentialStatus"];
            this.guardianName = _data["guardianName"];
            this.guardianPhone = _data["guardianPhone"];
            this.guardianOccupation = _data["guardianOccupation"];
            this.guardianRelationship = _data["guardianRelationship"];
            this.disability = _data["disability"];
            if (Array.isArray(_data["disabilityType"])) {
                this.disabilityType = [] as any;
                for (let item of _data["disabilityType"])
                    this.disabilityType!.push(item);
            }
            this.religionId = _data["religionId"];
            this.denomination = _data["denomination"];
            this.idCard = _data["idCard"];
            this.referrals = _data["referrals"];
            this.nationalIDNo = _data["nationalIDNo"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateBiodataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBiodataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicationNumber"] = this.applicationNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherName"] = this.otherName;
        data["previousName"] = this.previousName;
        data["noOfChildren"] = this.noOfChildren;
        data["gender"] = this.gender;
        data["dateOfBirth"] = this.dateOfBirth ? formatDate(this.dateOfBirth) : <any>undefined;
        data["month"] = this.month;
        data["year"] = this.year;
        data["day"] = this.day;
        data["title"] = this.title;
        data["maritalStatus"] = this.maritalStatus;
        data["phone"] = this.phone;
        data["altPhone"] = this.altPhone;
        data["email"] = this.email;
        data["emergencyContact"] = this.emergencyContact;
        data["hometown"] = this.hometown;
        data["district"] = this.district;
        data["regionId"] = this.regionId;
        data["nationalityId"] = this.nationalityId;
        data["residentialStatus"] = this.residentialStatus;
        data["guardianName"] = this.guardianName;
        data["guardianPhone"] = this.guardianPhone;
        data["guardianOccupation"] = this.guardianOccupation;
        data["guardianRelationship"] = this.guardianRelationship;
        data["disability"] = this.disability;
        if (Array.isArray(this.disabilityType)) {
            data["disabilityType"] = [];
            for (let item of this.disabilityType)
                data["disabilityType"].push(item);
        }
        data["religionId"] = this.religionId;
        data["denomination"] = this.denomination;
        data["idCard"] = this.idCard;
        data["referrals"] = this.referrals;
        data["nationalIDNo"] = this.nationalIDNo;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        return data;
    }
}

export interface ICreateBiodataRequest {
    id?: number | undefined;
    applicationNumber?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    otherName?: string | undefined;
    previousName?: string | undefined;
    noOfChildren?: number | undefined;
    gender?: Gender;
    dateOfBirth?: Date;
    month?: string | undefined;
    year?: string | undefined;
    day?: string | undefined;
    title?: Title;
    maritalStatus?: MaritalStatus | undefined;
    phone?: string | undefined;
    altPhone?: string | undefined;
    email?: string | undefined;
    emergencyContact?: string | undefined;
    hometown?: string | undefined;
    district?: number | undefined;
    regionId?: number | undefined;
    nationalityId?: number | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: string | undefined;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability[] | undefined;
    religionId?: number;
    denomination?: string | undefined;
    idCard?: IdCards;
    referrals?: string | undefined;
    nationalIDNo?: string | undefined;
    languages?: Languages[] | undefined;
}

export enum IdCards {
    GhanaCard = 0,
    VotersCard = 1,
    NHIS = 2,
    PassPort = 3,
    DriversLicense = 4,
    Other = 5,
    BirthCertificate = 6,
}

export enum Languages {
    English = 0,
    Ga = 1,
    Dangbe = 2,
    Dagbani = 3,
    Twi = 4,
    Ewe = 5,
    Kasem = 6,
    Gonja = 7,
    Fante = 8,
    French = 9,
    Spanish = 10,
    Dagaare = 11,
    Yoruba = 12,
    Igbo = 13,
    Hausa = 14,
    Nzema = 15,
}

export class ChoicesDto implements IChoicesDto {
    id?: number;
    firstChoice?: ProgrammeModel | undefined;
    secondChoice?: ProgrammeModel | undefined;
    thirdChoice?: ProgrammeModel | undefined;

    constructor(data?: IChoicesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstChoice = _data["firstChoice"] ? ProgrammeModel.fromJS(_data["firstChoice"]) : <any>undefined;
            this.secondChoice = _data["secondChoice"] ? ProgrammeModel.fromJS(_data["secondChoice"]) : <any>undefined;
            this.thirdChoice = _data["thirdChoice"] ? ProgrammeModel.fromJS(_data["thirdChoice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChoicesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChoicesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstChoice"] = this.firstChoice ? this.firstChoice.toJSON() : <any>undefined;
        data["secondChoice"] = this.secondChoice ? this.secondChoice.toJSON() : <any>undefined;
        data["thirdChoice"] = this.thirdChoice ? this.thirdChoice.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChoicesDto {
    id?: number;
    firstChoice?: ProgrammeModel | undefined;
    secondChoice?: ProgrammeModel | undefined;
    thirdChoice?: ProgrammeModel | undefined;
}

export class UserDto implements IUserDto {
    id?: string | undefined;
    formNo?: string | undefined;
    started?: boolean | undefined;
    fullName?: string | undefined;
    userName?: string | undefined;
    type?: ApplicationType;
    category?: string | undefined;
    sold?: boolean;
    soldBy?: string | undefined;
    branch?: string | undefined;
    teller?: string | undefined;
    tellerPhone?: string | undefined;
    formCompleted?: boolean | undefined;
    pictureUploaded?: boolean | undefined;
    finalized?: boolean | undefined;
    year?: string | undefined;
    resultUploaded?: boolean | undefined;
    admitted?: boolean;
    pin?: string | undefined;
    foreignApplicant?: boolean | undefined;
    lastLogin?: Date | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formNo = _data["formNo"];
            this.started = _data["started"];
            this.fullName = _data["fullName"];
            this.userName = _data["userName"];
            this.type = _data["type"];
            this.category = _data["category"];
            this.sold = _data["sold"];
            this.soldBy = _data["soldBy"];
            this.branch = _data["branch"];
            this.teller = _data["teller"];
            this.tellerPhone = _data["tellerPhone"];
            this.formCompleted = _data["formCompleted"];
            this.pictureUploaded = _data["pictureUploaded"];
            this.finalized = _data["finalized"];
            this.year = _data["year"];
            this.resultUploaded = _data["resultUploaded"];
            this.admitted = _data["admitted"];
            this.pin = _data["pin"];
            this.foreignApplicant = _data["foreignApplicant"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formNo"] = this.formNo;
        data["started"] = this.started;
        data["fullName"] = this.fullName;
        data["userName"] = this.userName;
        data["type"] = this.type;
        data["category"] = this.category;
        data["sold"] = this.sold;
        data["soldBy"] = this.soldBy;
        data["branch"] = this.branch;
        data["teller"] = this.teller;
        data["tellerPhone"] = this.tellerPhone;
        data["formCompleted"] = this.formCompleted;
        data["pictureUploaded"] = this.pictureUploaded;
        data["finalized"] = this.finalized;
        data["year"] = this.year;
        data["resultUploaded"] = this.resultUploaded;
        data["admitted"] = this.admitted;
        data["pin"] = this.pin;
        data["foreignApplicant"] = this.foreignApplicant;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserDto {
    id?: string | undefined;
    formNo?: string | undefined;
    started?: boolean | undefined;
    fullName?: string | undefined;
    userName?: string | undefined;
    type?: ApplicationType;
    category?: string | undefined;
    sold?: boolean;
    soldBy?: string | undefined;
    branch?: string | undefined;
    teller?: string | undefined;
    tellerPhone?: string | undefined;
    formCompleted?: boolean | undefined;
    pictureUploaded?: boolean | undefined;
    finalized?: boolean | undefined;
    year?: string | undefined;
    resultUploaded?: boolean | undefined;
    admitted?: boolean;
    pin?: string | undefined;
    foreignApplicant?: boolean | undefined;
    lastLogin?: Date | undefined;
}

export class PaginatedListOfDocumentUploadDto implements IPaginatedListOfDocumentUploadDto {
    items?: DocumentUploadDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfDocumentUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DocumentUploadDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfDocumentUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfDocumentUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfDocumentUploadDto {
    items?: DocumentUploadDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class DocumentUploadDto implements IDocumentUploadDto {
    id?: number;
    applicant?: number;
    name?: string | undefined;
    type?: string | undefined;

    constructor(data?: IDocumentUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): DocumentUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

export interface IDocumentUploadDto {
    id?: number;
    applicant?: number;
    name?: string | undefined;
    type?: string | undefined;
}

export class UploadDocumentRequest implements IUploadDocumentRequest {
    userId?: string | undefined;
    id?: number;
    applicant?: number;
    name?: string | undefined;
    type?: string | undefined;
    files?: FileDto[];

    constructor(data?: IUploadDocumentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.applicant = _data["applicant"];
            this.name = _data["name"];
            this.type = _data["type"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UploadDocumentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDocumentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["applicant"] = this.applicant;
        data["name"] = this.name;
        data["type"] = this.type;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUploadDocumentRequest {
    userId?: string | undefined;
    id?: number;
    applicant?: number;
    name?: string | undefined;
    type?: string | undefined;
    files?: FileDto[];
}

export class FileDto implements IFileDto {
    content?: Stream | undefined;
    name?: string | undefined;
    userId?: string | undefined;
    contentType?: string | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"] ? Stream.fromJS(_data["content"]) : <any>undefined;
            this.name = _data["name"];
            this.userId = _data["userId"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["userId"] = this.userId;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IFileDto {
    content?: Stream | undefined;
    name?: string | undefined;
    userId?: string | undefined;
    contentType?: string | undefined;
}

export abstract class MarshalByRefObject implements IMarshalByRefObject {

    constructor(data?: IMarshalByRefObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): MarshalByRefObject {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MarshalByRefObject' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IMarshalByRefObject {
}

export abstract class Stream extends MarshalByRefObject implements IStream {
    canRead?: boolean;
    canWrite?: boolean;
    canSeek?: boolean;
    canTimeout?: boolean;
    length?: number;
    position?: number;
    readTimeout?: number;
    writeTimeout?: number;

    constructor(data?: IStream) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.canRead = _data["canRead"];
            this.canWrite = _data["canWrite"];
            this.canSeek = _data["canSeek"];
            this.canTimeout = _data["canTimeout"];
            this.length = _data["length"];
            this.position = _data["position"];
            this.readTimeout = _data["readTimeout"];
            this.writeTimeout = _data["writeTimeout"];
        }
    }

    static override fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Stream' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canRead"] = this.canRead;
        data["canWrite"] = this.canWrite;
        data["canSeek"] = this.canSeek;
        data["canTimeout"] = this.canTimeout;
        data["length"] = this.length;
        data["position"] = this.position;
        data["readTimeout"] = this.readTimeout;
        data["writeTimeout"] = this.writeTimeout;
        super.toJSON(data);
        return data;
    }
}

export interface IStream extends IMarshalByRefObject {
    canRead?: boolean;
    canWrite?: boolean;
    canSeek?: boolean;
    canTimeout?: boolean;
    length?: number;
    position?: number;
    readTimeout?: number;
    writeTimeout?: number;
}

export class PaginatedListOfSHSAttendedDto implements IPaginatedListOfSHSAttendedDto {
    items?: SHSAttendedDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfSHSAttendedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SHSAttendedDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfSHSAttendedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSHSAttendedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfSHSAttendedDto {
    items?: SHSAttendedDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SHSAttendedDto implements ISHSAttendedDto {
    id?: number;
    attendedTTU?: boolean;
    applicant?: ApplicantModel | undefined;
    name?: FormerSchoolModel | undefined;
    location?: RegionModel | undefined;
    startYear?: number | undefined;
    endYear?: number | undefined;
    programmeStudied?: string | undefined;

    constructor(data?: ISHSAttendedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.attendedTTU = _data["attendedTTU"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
            this.name = _data["name"] ? FormerSchoolModel.fromJS(_data["name"]) : <any>undefined;
            this.location = _data["location"] ? RegionModel.fromJS(_data["location"]) : <any>undefined;
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
            this.programmeStudied = _data["programmeStudied"];
        }
    }

    static fromJS(data: any): SHSAttendedDto {
        data = typeof data === 'object' ? data : {};
        let result = new SHSAttendedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attendedTTU"] = this.attendedTTU;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        data["programmeStudied"] = this.programmeStudied;
        return data;
    }
}

export interface ISHSAttendedDto {
    id?: number;
    attendedTTU?: boolean;
    applicant?: ApplicantModel | undefined;
    name?: FormerSchoolModel | undefined;
    location?: RegionModel | undefined;
    startYear?: number | undefined;
    endYear?: number | undefined;
    programmeStudied?: string | undefined;
}

export class SHSAttendedRequest implements ISHSAttendedRequest {
    nameId?: number | undefined;
    programmeStudied?: string | undefined;
    region?: number | undefined;
    applicant?: number | undefined;
    startYear?: number | undefined;
    endYear?: number | undefined;

    constructor(data?: ISHSAttendedRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameId = _data["nameId"];
            this.programmeStudied = _data["programmeStudied"];
            this.region = _data["region"];
            this.applicant = _data["applicant"];
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
        }
    }

    static fromJS(data: any): SHSAttendedRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SHSAttendedRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameId"] = this.nameId;
        data["programmeStudied"] = this.programmeStudied;
        data["region"] = this.region;
        data["applicant"] = this.applicant;
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        return data;
    }
}

export interface ISHSAttendedRequest {
    nameId?: number | undefined;
    programmeStudied?: string | undefined;
    region?: number | undefined;
    applicant?: number | undefined;
    startYear?: number | undefined;
    endYear?: number | undefined;
}

export class UploadPictureRequest implements IUploadPictureRequest {
    userId?: string | undefined;
    files?: FileDto[];

    constructor(data?: IUploadPictureRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UploadPictureRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadPictureRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUploadPictureRequest {
    userId?: string | undefined;
    files?: FileDto[];
}

export class UniversityAttendedDto implements IUniversityAttendedDto {
    id?: number | undefined;
    applicant?: ApplicantModel | undefined;
    name?: string | undefined;
    location?: CountryModel | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;
    studentNumber?: string | undefined;
    degreeObtained?: string | undefined;
    degreeClassification?: string | undefined;
    cgpa?: number | undefined;

    constructor(data?: IUniversityAttendedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
            this.name = _data["name"];
            this.location = _data["location"] ? CountryModel.fromJS(_data["location"]) : <any>undefined;
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
            this.studentNumber = _data["studentNumber"];
            this.degreeObtained = _data["degreeObtained"];
            this.degreeClassification = _data["degreeClassification"];
            this.cgpa = _data["cgpa"];
        }
    }

    static fromJS(data: any): UniversityAttendedDto {
        data = typeof data === 'object' ? data : {};
        let result = new UniversityAttendedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        data["studentNumber"] = this.studentNumber;
        data["degreeObtained"] = this.degreeObtained;
        data["degreeClassification"] = this.degreeClassification;
        data["cgpa"] = this.cgpa;
        return data;
    }
}

export interface IUniversityAttendedDto {
    id?: number | undefined;
    applicant?: ApplicantModel | undefined;
    name?: string | undefined;
    location?: CountryModel | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;
    studentNumber?: string | undefined;
    degreeObtained?: string | undefined;
    degreeClassification?: string | undefined;
    cgpa?: number | undefined;
}

export class ProgrammeDto implements IProgrammeDto {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    levelAdmitted?: string | undefined;
    running?: boolean | undefined;
    showOnPortal?: boolean | undefined;
    type?: string | undefined;
    duration?: number;
    department?: number;

    constructor(data?: IProgrammeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.levelAdmitted = _data["levelAdmitted"];
            this.running = _data["running"];
            this.showOnPortal = _data["showOnPortal"];
            this.type = _data["type"];
            this.duration = _data["duration"];
            this.department = _data["department"];
        }
    }

    static fromJS(data: any): ProgrammeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgrammeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["levelAdmitted"] = this.levelAdmitted;
        data["running"] = this.running;
        data["showOnPortal"] = this.showOnPortal;
        data["type"] = this.type;
        data["duration"] = this.duration;
        data["department"] = this.department;
        return data;
    }
}

export interface IProgrammeDto {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    levelAdmitted?: string | undefined;
    running?: boolean | undefined;
    showOnPortal?: boolean | undefined;
    type?: string | undefined;
    duration?: number;
    department?: number;
}

export class FinalizedRequest implements IFinalizedRequest {
    id?: string | undefined;

    constructor(data?: IFinalizedRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FinalizedRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FinalizedRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IFinalizedRequest {
    id?: string | undefined;
}

export class ProgrammeInfoRequest implements IProgrammeInfoRequest {
    id?: string | undefined;
    entryMode?: Session | undefined;
    firstQualification?: EntryQualification | undefined;
    secondQualification?: EntryQualification | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    awaiting?: boolean | undefined;
    lastYearInSchool?: number | undefined;
    sponsorship?: boolean | undefined;
    sponsorshipCompany?: string | undefined;
    sponsorshipLocation?: string | undefined;
    sponsorshipCompanyContact?: string | undefined;
    previousIndexNumber?: string | undefined;
    sourceOfFinance?: string | undefined;

    constructor(data?: IProgrammeInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entryMode = _data["entryMode"];
            this.firstQualification = _data["firstQualification"];
            this.secondQualification = _data["secondQualification"];
            this.firstChoiceId = _data["firstChoiceId"];
            this.secondChoiceId = _data["secondChoiceId"];
            this.thirdChoiceId = _data["thirdChoiceId"];
            this.awaiting = _data["awaiting"];
            this.lastYearInSchool = _data["lastYearInSchool"];
            this.sponsorship = _data["sponsorship"];
            this.sponsorshipCompany = _data["sponsorshipCompany"];
            this.sponsorshipLocation = _data["sponsorshipLocation"];
            this.sponsorshipCompanyContact = _data["sponsorshipCompanyContact"];
            this.previousIndexNumber = _data["previousIndexNumber"];
            this.sourceOfFinance = _data["sourceOfFinance"];
        }
    }

    static fromJS(data: any): ProgrammeInfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProgrammeInfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entryMode"] = this.entryMode;
        data["firstQualification"] = this.firstQualification;
        data["secondQualification"] = this.secondQualification;
        data["firstChoiceId"] = this.firstChoiceId;
        data["secondChoiceId"] = this.secondChoiceId;
        data["thirdChoiceId"] = this.thirdChoiceId;
        data["awaiting"] = this.awaiting;
        data["lastYearInSchool"] = this.lastYearInSchool;
        data["sponsorship"] = this.sponsorship;
        data["sponsorshipCompany"] = this.sponsorshipCompany;
        data["sponsorshipLocation"] = this.sponsorshipLocation;
        data["sponsorshipCompanyContact"] = this.sponsorshipCompanyContact;
        data["previousIndexNumber"] = this.previousIndexNumber;
        data["sourceOfFinance"] = this.sourceOfFinance;
        return data;
    }
}

export interface IProgrammeInfoRequest {
    id?: string | undefined;
    entryMode?: Session | undefined;
    firstQualification?: EntryQualification | undefined;
    secondQualification?: EntryQualification | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    awaiting?: boolean | undefined;
    lastYearInSchool?: number | undefined;
    sponsorship?: boolean | undefined;
    sponsorshipCompany?: string | undefined;
    sponsorshipLocation?: string | undefined;
    sponsorshipCompanyContact?: string | undefined;
    previousIndexNumber?: string | undefined;
    sourceOfFinance?: string | undefined;
}

export class PaginatedListOfRefereeDto implements IPaginatedListOfRefereeDto {
    items?: RefereeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfRefereeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RefereeDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfRefereeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfRefereeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfRefereeDto {
    items?: RefereeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class RefereeDto implements IRefereeDto {
    id?: number | undefined;
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicant?: number | undefined;

    constructor(data?: IRefereeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.institution = _data["institution"];
            this.email = _data["email"];
            this.position = _data["position"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): RefereeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefereeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["institution"] = this.institution;
        data["email"] = this.email;
        data["position"] = this.position;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface IRefereeDto {
    id?: number | undefined;
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicant?: number | undefined;
}

export class CreateRefereeRequest implements ICreateRefereeRequest {
    id?: number;
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicantModel?: number | undefined;

    constructor(data?: ICreateRefereeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.institution = _data["institution"];
            this.email = _data["email"];
            this.position = _data["position"];
            this.applicantModel = _data["applicantModel"];
        }
    }

    static fromJS(data: any): CreateRefereeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRefereeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["institution"] = this.institution;
        data["email"] = this.email;
        data["position"] = this.position;
        data["applicantModel"] = this.applicantModel;
        return data;
    }
}

export interface ICreateRefereeRequest {
    id?: number;
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicantModel?: number | undefined;
}

export class PaginatedListOfResearchExperienceDto implements IPaginatedListOfResearchExperienceDto {
    items?: ResearchExperienceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfResearchExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResearchExperienceDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfResearchExperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfResearchExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfResearchExperienceDto {
    items?: ResearchExperienceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResearchExperienceDto implements IResearchExperienceDto {
    id?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;
    applicant?: number;

    constructor(data?: IResearchExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.month = _data["month"];
            this.areaOfResearchIfAdmitted = _data["areaOfResearchIfAdmitted"];
            this.actualAreaOfResearch = _data["actualAreaOfResearch"];
            this.futureResearchInterest = _data["futureResearchInterest"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): ResearchExperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["month"] = this.month;
        data["areaOfResearchIfAdmitted"] = this.areaOfResearchIfAdmitted;
        data["actualAreaOfResearch"] = this.actualAreaOfResearch;
        data["futureResearchInterest"] = this.futureResearchInterest;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface IResearchExperienceDto {
    id?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;
    applicant?: number;
}

export class ResearchExperienceRequest implements IResearchExperienceRequest {
    id?: number | undefined;
    applicant?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;

    constructor(data?: IResearchExperienceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"];
            this.title = _data["title"];
            this.month = _data["month"];
            this.areaOfResearchIfAdmitted = _data["areaOfResearchIfAdmitted"];
            this.actualAreaOfResearch = _data["actualAreaOfResearch"];
            this.futureResearchInterest = _data["futureResearchInterest"];
        }
    }

    static fromJS(data: any): ResearchExperienceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchExperienceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant;
        data["title"] = this.title;
        data["month"] = this.month;
        data["areaOfResearchIfAdmitted"] = this.areaOfResearchIfAdmitted;
        data["actualAreaOfResearch"] = this.actualAreaOfResearch;
        data["futureResearchInterest"] = this.futureResearchInterest;
        return data;
    }
}

export interface IResearchExperienceRequest {
    id?: number | undefined;
    applicant?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;
}

export class PaginatedListOfResearchPublicationDto implements IPaginatedListOfResearchPublicationDto {
    items?: ResearchPublicationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfResearchPublicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResearchPublicationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfResearchPublicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfResearchPublicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfResearchPublicationDto {
    items?: ResearchPublicationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResearchPublicationDto implements IResearchPublicationDto {
    id?: number;
    applicant?: number;
    publication?: string | undefined;

    constructor(data?: IResearchPublicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"];
            this.publication = _data["publication"];
        }
    }

    static fromJS(data: any): ResearchPublicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchPublicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant;
        data["publication"] = this.publication;
        return data;
    }
}

export interface IResearchPublicationDto {
    id?: number;
    applicant?: number;
    publication?: string | undefined;
}

export class ResearchPublicationRequest implements IResearchPublicationRequest {
    id?: number;
    applicant?: number;
    publication?: string | undefined;

    constructor(data?: IResearchPublicationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"];
            this.publication = _data["publication"];
        }
    }

    static fromJS(data: any): ResearchPublicationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchPublicationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant;
        data["publication"] = this.publication;
        return data;
    }
}

export interface IResearchPublicationRequest {
    id?: number;
    applicant?: number;
    publication?: string | undefined;
}

export class PaginatedListOfResultsDto implements IPaginatedListOfResultsDto {
    items?: ResultsDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfResultsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResultsDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfResultsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfResultsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfResultsDto {
    items?: ResultsDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultsDto implements IResultsDto {
    id?: number;
    subjectId?: number;
    examType?: string | undefined;
    gradeId?: number;
    gradeOld?: number | undefined;
    gradeValueOld?: string | undefined;
    indexNo?: string | undefined;
    sitting?: string | undefined;
    month?: string | undefined;
    form?: number;
    center?: string | undefined;
    year?: string | undefined;
    oldSubject?: string | undefined;
    institutionName?: string | undefined;
    applicantId?: number;
    applicant?: ApplicantModel | undefined;
    subject?: SubjectModel | undefined;
    grade?: GradeModel | undefined;

    constructor(data?: IResultsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectId = _data["subjectId"];
            this.examType = _data["examType"];
            this.gradeId = _data["gradeId"];
            this.gradeOld = _data["gradeOld"];
            this.gradeValueOld = _data["gradeValueOld"];
            this.indexNo = _data["indexNo"];
            this.sitting = _data["sitting"];
            this.month = _data["month"];
            this.form = _data["form"];
            this.center = _data["center"];
            this.year = _data["year"];
            this.oldSubject = _data["oldSubject"];
            this.institutionName = _data["institutionName"];
            this.applicantId = _data["applicantId"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
            this.subject = _data["subject"] ? SubjectModel.fromJS(_data["subject"]) : <any>undefined;
            this.grade = _data["grade"] ? GradeModel.fromJS(_data["grade"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResultsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectId"] = this.subjectId;
        data["examType"] = this.examType;
        data["gradeId"] = this.gradeId;
        data["gradeOld"] = this.gradeOld;
        data["gradeValueOld"] = this.gradeValueOld;
        data["indexNo"] = this.indexNo;
        data["sitting"] = this.sitting;
        data["month"] = this.month;
        data["form"] = this.form;
        data["center"] = this.center;
        data["year"] = this.year;
        data["oldSubject"] = this.oldSubject;
        data["institutionName"] = this.institutionName;
        data["applicantId"] = this.applicantId;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResultsDto {
    id?: number;
    subjectId?: number;
    examType?: string | undefined;
    gradeId?: number;
    gradeOld?: number | undefined;
    gradeValueOld?: string | undefined;
    indexNo?: string | undefined;
    sitting?: string | undefined;
    month?: string | undefined;
    form?: number;
    center?: string | undefined;
    year?: string | undefined;
    oldSubject?: string | undefined;
    institutionName?: string | undefined;
    applicantId?: number;
    applicant?: ApplicantModel | undefined;
    subject?: SubjectModel | undefined;
    grade?: GradeModel | undefined;
}

export class CreateResultRequest implements ICreateResultRequest {
    applicant?: number;
    subjectId?: number | undefined;
    examType?: string | undefined;
    gradeId?: number | undefined;
    indexNo?: string | undefined;
    sitting?: string | undefined;
    month?: string | undefined;
    center?: string | undefined;
    year?: string | undefined;
    institutionName?: string | undefined;

    constructor(data?: ICreateResultRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicant = _data["applicant"];
            this.subjectId = _data["subjectId"];
            this.examType = _data["examType"];
            this.gradeId = _data["gradeId"];
            this.indexNo = _data["indexNo"];
            this.sitting = _data["sitting"];
            this.month = _data["month"];
            this.center = _data["center"];
            this.year = _data["year"];
            this.institutionName = _data["institutionName"];
        }
    }

    static fromJS(data: any): CreateResultRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateResultRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicant"] = this.applicant;
        data["subjectId"] = this.subjectId;
        data["examType"] = this.examType;
        data["gradeId"] = this.gradeId;
        data["indexNo"] = this.indexNo;
        data["sitting"] = this.sitting;
        data["month"] = this.month;
        data["center"] = this.center;
        data["year"] = this.year;
        data["institutionName"] = this.institutionName;
        return data;
    }
}

export interface ICreateResultRequest {
    applicant?: number;
    subjectId?: number | undefined;
    examType?: string | undefined;
    gradeId?: number | undefined;
    indexNo?: string | undefined;
    sitting?: string | undefined;
    month?: string | undefined;
    center?: string | undefined;
    year?: string | undefined;
    institutionName?: string | undefined;
}

export class RegionDto implements IRegionDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRegionDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class CountryDto implements ICountryDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class FormerSchoolDto implements IFormerSchoolDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IFormerSchoolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FormerSchoolDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormerSchoolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IFormerSchoolDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class DenominationDto implements IDenominationDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IDenominationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DenominationDto {
        data = typeof data === 'object' ? data : {};
        let result = new DenominationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IDenominationDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class ReligionDto implements IReligionDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IReligionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ReligionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReligionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IReligionDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class SHSProgrammesDto implements ISHSProgrammesDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: ISHSProgrammesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SHSProgrammesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SHSProgrammesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISHSProgrammesDto {
    id?: number;
    name?: string | undefined;
}

export class SubjectDto implements ISubjectDto {
    id?: number | undefined;
    exam?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;

    constructor(data?: ISubjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exam = _data["exam"];
            this.type = _data["type"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SubjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exam"] = this.exam;
        data["type"] = this.type;
        data["name"] = this.name;
        return data;
    }
}

export interface ISubjectDto {
    id?: number | undefined;
    exam?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;
}

export class LanguageDto implements ILanguageDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: ILanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ILanguageDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class GradeDto implements IGradeDto {
    id?: number | undefined;
    name?: string | undefined;
    value?: number | undefined;

    constructor(data?: IGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IGradeDto {
    id?: number | undefined;
    name?: string | undefined;
    value?: number | undefined;
}

export class ExamDto implements IExamDto {
    id?: number | undefined;
    name?: string | undefined;
    cutOffPoint?: number | undefined;

    constructor(data?: IExamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.cutOffPoint = _data["cutOffPoint"];
        }
    }

    static fromJS(data: any): ExamDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["cutOffPoint"] = this.cutOffPoint;
        return data;
    }
}

export interface IExamDto {
    id?: number | undefined;
    name?: string | undefined;
    cutOffPoint?: number | undefined;
}

export class DistrictDto implements IDistrictDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IDistrictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DistrictDto {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IDistrictDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class PaginatedListOfTodoItemBriefDto implements IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemBriefDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TodoItemBriefDto implements ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: ITodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): TodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listId = _data["listId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: LookupDto[];
    lists?: TodoListDto[];

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of _data["priorityLevels"])
                    this.priorityLevels!.push(LookupDto.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodosVm {
    priorityLevels?: LookupDto[];
    lists?: TodoListDto[];
}

export class LookupDto implements ILookupDto {
    id?: number;
    title?: string | undefined;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface ILookupDto {
    id?: number;
    title?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.colour = _data["colour"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["colour"] = this.colour;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static override fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;
}

export class RegisterRequest implements IRegisterRequest {
    email?: string;
    password?: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    email?: string;
    password?: string;
}

export class AccessTokenResponse implements IAccessTokenResponse {
    tokenType?: string;
    accessToken?: string;
    expiresIn?: number;
    refreshToken?: string;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tokenType = _data["tokenType"];
            this.accessToken = _data["accessToken"];
            this.expiresIn = _data["expiresIn"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType;
        data["accessToken"] = this.accessToken;
        data["expiresIn"] = this.expiresIn;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAccessTokenResponse {
    tokenType?: string;
    accessToken?: string;
    expiresIn?: number;
    refreshToken?: string;
}

export class LoginRequest implements ILoginRequest {
    email?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode;
        return data;
    }
}

export interface ILoginRequest {
    email?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken?: string;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken?: string;
}

export class ResendConfirmationEmailRequest implements IResendConfirmationEmailRequest {
    email?: string;

    constructor(data?: IResendConfirmationEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendConfirmationEmailRequest {
    email?: string;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email?: string;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email?: string;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email?: string;
    resetCode?: string;
    newPassword?: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetCode = _data["resetCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetCode"] = this.resetCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email?: string;
    resetCode?: string;
    newPassword?: string;
}

export class TwoFactorResponse implements ITwoFactorResponse {
    sharedKey?: string;
    recoveryCodesLeft?: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled?: boolean;
    isMachineRemembered?: boolean;

    constructor(data?: ITwoFactorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"];
            this.recoveryCodesLeft = _data["recoveryCodesLeft"];
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isMachineRemembered = _data["isMachineRemembered"];
        }
    }

    static fromJS(data: any): TwoFactorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey;
        data["recoveryCodesLeft"] = this.recoveryCodesLeft;
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isMachineRemembered"] = this.isMachineRemembered;
        return data;
    }
}

export interface ITwoFactorResponse {
    sharedKey?: string;
    recoveryCodesLeft?: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled?: boolean;
    isMachineRemembered?: boolean;
}

export class TwoFactorRequest implements ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;

    constructor(data?: ITwoFactorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enable = _data["enable"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.resetSharedKey = _data["resetSharedKey"];
            this.resetRecoveryCodes = _data["resetRecoveryCodes"];
            this.forgetMachine = _data["forgetMachine"];
        }
    }

    static fromJS(data: any): TwoFactorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enable"] = this.enable;
        data["twoFactorCode"] = this.twoFactorCode;
        data["resetSharedKey"] = this.resetSharedKey;
        data["resetRecoveryCodes"] = this.resetRecoveryCodes;
        data["forgetMachine"] = this.forgetMachine;
        return data;
    }
}

export interface ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;
}

export class InfoResponse implements IInfoResponse {
    email?: string;
    isEmailConfirmed?: boolean;

    constructor(data?: IInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
        }
    }

    static fromJS(data: any): InfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        return data;
    }
}

export interface IInfoResponse {
    email?: string;
    isEmailConfirmed?: boolean;
}

export class InfoRequest implements IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;

    constructor(data?: IInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newEmail = _data["newEmail"];
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): InfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newEmail"] = this.newEmail;
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class PaginatedListOfWorkingExperienceDto implements IPaginatedListOfWorkingExperienceDto {
    items?: WorkingExperienceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfWorkingExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WorkingExperienceDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfWorkingExperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfWorkingExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfWorkingExperienceDto {
    items?: WorkingExperienceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WorkingExperienceDto implements IWorkingExperienceDto {
    id?: number;
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyAddress?: string | undefined;
    companyPosition?: string | undefined;
    companyFrom?: string | undefined;
    companyTo?: string | undefined;
    applicant?: number;

    constructor(data?: IWorkingExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.companyPhone = _data["companyPhone"];
            this.companyAddress = _data["companyAddress"];
            this.companyPosition = _data["companyPosition"];
            this.companyFrom = _data["companyFrom"];
            this.companyTo = _data["companyTo"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): WorkingExperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["companyPhone"] = this.companyPhone;
        data["companyAddress"] = this.companyAddress;
        data["companyPosition"] = this.companyPosition;
        data["companyFrom"] = this.companyFrom;
        data["companyTo"] = this.companyTo;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface IWorkingExperienceDto {
    id?: number;
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyAddress?: string | undefined;
    companyPosition?: string | undefined;
    companyFrom?: string | undefined;
    companyTo?: string | undefined;
    applicant?: number;
}

export class WorkingExperienceRequest implements IWorkingExperienceRequest {
    id?: number;
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyAddress?: string | undefined;
    companyPosition?: string | undefined;
    companyFrom?: string | undefined;
    companyTo?: string | undefined;
    applicant?: number;

    constructor(data?: IWorkingExperienceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.companyPhone = _data["companyPhone"];
            this.companyAddress = _data["companyAddress"];
            this.companyPosition = _data["companyPosition"];
            this.companyFrom = _data["companyFrom"];
            this.companyTo = _data["companyTo"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): WorkingExperienceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingExperienceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["companyPhone"] = this.companyPhone;
        data["companyAddress"] = this.companyAddress;
        data["companyPosition"] = this.companyPosition;
        data["companyFrom"] = this.companyFrom;
        data["companyTo"] = this.companyTo;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface IWorkingExperienceRequest {
    id?: number;
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyAddress?: string | undefined;
    companyPosition?: string | undefined;
    companyFrom?: string | undefined;
    companyTo?: string | undefined;
    applicant?: number;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}